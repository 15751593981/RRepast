{
    "collab_server" : "",
    "contents" : "##================================================================================\n## This file is part of the rrepast package - R/Repast interface API\n## \n## (C)2015 Antonio Prestes Garcia <@>\n## For license terms see DESCRIPTION and/or LICENSE\n##\n## $Id$\n##================================================================================\n\n\n# ------------------------------------------------------------\n# .onLoad, Hook for loading package namespace\n# \n# ------------------------------------------------------------\n.onLoad<- function(libname, pkgname) {\n  #packageStartupMessage(\"R/Repast: Integrating Repast Models into R\\n\")\n  assign(\"pkg.globals\", new.env(), envir=parent.env(environment()))\n  \n  # Internal variables\n  assign(\"pkg.basedir\", NA, pkg.globals)\n  assign(\"pkg.modeldir\", NA, pkg.globals)\n  assign(\"pkg.scenariodir\", NA, pkg.globals)\n  assign(\"pkg.modellibdir\", NA, pkg.globals)\n  assign(\"pkg.id\", NA, pkg.globals)\n  \n  # global simulation results\n  assign(\"pkg.parameters\", data.frame(), pkg.globals)\n  assign(\"pkg.results\", data.frame(), pkg.globals)\n  \n  # progress bar internals\n  assign(\"pkg.progressbar\", NULL, pkg.globals)\n  assign(\"pkg.progressbar.enabled\", FALSE, pkg.globals)\n\n  # default values for model\n  assign(\"pkg.outputdir\",paste0(Sys.getenv(\"TMP\"),\"/rrepast-deployment/\"), pkg.globals)\n  assign(\"pkg.repastlibdir\", \"/repast.simphony/\", pkg.globals)\n  assign(\"pkg.java.parameters\",\"-server -Xms512m -Xmx1024m\", pkg.globals)\n  \n  # default key for Repast random seed \n  assign(\"pkg.randomSeed\",\"randomSeed\", pkg.globals)\n  \n  # The Random Seed. You may want to change this.\n  set.seed(exp(1)*10^6)\n  \n  # Define funcions which are not present in ond R versions\n  compatibility()\n}\n\n\n\n# ----- internal functions \n\n# Define some required functions when not available from current R version\ncompatibility<- function() {\n  if(getRversion() <= \"3.1\") {\n    # dir.exists function is only available from R 3.2\n    f<- function(d) {\n      cat(\"my dir.exists()\")\n      v<- file.info(d)$isdir\n      return(ifelse(is.na(v), FALSE, v))\n    }\n    \n    # This is a trick to get the reference to the current environment\n    e<- as.environment(environment(enginejar))\n    assign(\"dir.exists\", f, e, immediate = FALSE)\n  }\n}\n\n# Returns the xml integration string\nxml.integration<- function() {\n  \"<model.initializer class=\\\"org.haldane.rrepast.ModelInitializerBroker\\\" />\"\n}\n\n# Returns the wrapper classes jar file location. \nenginejar<- function() {\n\n  # Try to guess the rrepast-engine.jar location  \n  for(p in .libPaths()) {\n    f0<- paste0(p,\"/rrepast/java/rrepast-engine.jar\")\n    f1<- paste0(p,\"/rrepast/inst/java/rrepast-engine.jar\")\n    if(file.exists(f0)) {\n      f<- f0\n      break\n    } else if(file.exists(f1)) {\n        f<- f1\n        break\n    }\n  }\n  return(f)\n}\n\n#' @title jarfile\n#' \n#' @description The jarfile returns the full path to some jar file \n#' available inside rrpast package\n#' \n#' @param fjar The name of jar file\n#' \n#' @return The full path to jar file\n#' @export\njarfile<- function(fjar) {\n  for(p in .libPaths()) {\n    f0<- paste0(p,\"/rrepast/java/\",fjar)\n    f1<- paste0(p,\"/rrepast/inst/java/\",fjar)\n    \n    if(file.exists(f0)) {\n      f<- f0\n      break\n    } else if(file.exists(f1)) {\n      f<- f1\n      break\n    }\n  }\n  return(f)\n}\n\n#' @title config.scenario\n#' \n#' @description Add the integration library to the model's configuration\n#' \n#' @param modelpath The path where model is installed\n#' @param uninstall If TRUE restore original scenario.xml file\n#' \n#' @export\nconfig.scenario<- function(modelpath, uninstall=FALSE) {\n  status<- FALSE\n  i<- 1\n  v<- c()\n  if(!check.scenario(modelpath)) {\n    fscenario<- paste0(getScenarioDir(),\"/\",\"scenario.xml\")\n    if(file.exists(fscenario)) {\n      ## Backup the original scenario file\n      if(file.copy(fscenario,paste0(fscenario,\".ORIGINAL\"))) {\n        txts<- readLines(fscenario, warn= FALSE)\n        for(j in 1:length(txts)) {\n          v[i]<- txts[j]\n          if(length(grep(\"<Scenario>\",txts[j]))) {\n            v[(i<- i + 1)]<- xml.integration()\n          } \n          i<- i + 1  \n        }  \n        ## Write the new scenario file\n        writeLines(v,fscenario)\n        status<- TRUE\n      }\n    }\n  } else {\n    ## Restore the original scenario file\n    if(uninstall) {\n      fscenario<- paste0(getScenarioDir(),\"/\",\"scenario.xml\")\n      status<- file.copy(paste0(fscenario,\".ORIGINAL\"),fscenario) \n    }\n  }\n  return(status)\n}\n\n#' @title config.copylib\n#' \n#' @description Install or uninstall the integration jar file. This function \n#' manages the installation process of required jars to the model lib dir.\n#' \n#' @param modelpath The path where model is installed\n#' @param uninstall If TRUE uninstall integration jar\n#' \n#' @export\nconfig.copylib<- function(modelpath, uninstall=FALSE) {\n  configModelDirs(modelpath)\n  jjar<- \"rrepast-integration.jar\"\n  ljar<- paste0(getModelLibDir(),\"/\",jjar)\n  sjar<- jarfile(jjar)\n  \n  if(file.exists(ljar)) {\n    if(uninstall) {\n      v<- file.remove(ljar)\n    }\n  } else {\n    v<- file.copy(sjar,ljar)\n  }\n  return(v)\n}\n\n#' @title config.check\n#' \n#' @description Verify if the installed model is correctelly configurated.\n#' \n#' @param modelpath The path where model is installed\n#' \n#' @return TRUE when all requisites are met\n#' @export\nconfig.check<- function(modelpath) {\n  return(check.scenario(modelpath) && check.integration(modelpath))\n}\n  \n#' @title check.scenario\n#' \n#' @description Check if the scenario.xml is configured with the rrepast \n#' itegration code\n#' \n#' @param modelpath The path where model is installed\n#' \n#' @return TRUE if scenario is properly configured\n#' @export\ncheck.scenario<- function(modelpath) {\n  v<- FALSE\n  configModelDirs(modelpath)\n  fscenario<- paste0(getScenarioDir(),\"/\",\"scenario.xml\")\n  if(file.exists(fscenario)) {\n    if(length(grep(xml.integration(),readLines(fscenario, warn= FALSE)))) {\n      v<- TRUE\n    }\n  }\n  return(v)\n}\n\n#' @title check.integration\n#' \n#' @description Check if the integration jar library is correctelly installed \n#' in the model lib directory\n#' \n#' @param modelpath The path where model is installed\n#' \n#' @return TRUE if the integration code is correctelly deployed\n#' @export\ncheck.integration<- function(modelpath) {\n  configModelDirs(modelpath)\n  return(file.exists(paste0(getModelLibDir(),\"/\",\"rrepast-integration.jar\")))\n}\n\n\n# Return the name of repast engine class name. \nengineclazz<- function() {\n  return(\"org.haldane.rrepast.RepastEngine\")\n}\n\n# Returns the repast simphony library dir\nsimphonylib<- function() {\n  b<- get(\"pkg.basedir\", pkg.globals)\n  l<- get(\"pkg.repastlibdir\", pkg.globals)\n  return(paste0(b,l))\n}\n\n# Configure all model directories based on default installation values\nconfigModelDirs<- function(s) {\n  d<- basename(s)\n  setBaseDir(s)\n  setModelDir(paste0(paste0(s,\"/\"),d))\n  setScenarioDir(paste0(paste0(paste0(getModelDir(),\"/\"),d),\".rs\"))\n  setModelLibDir(paste0(getModelDir(),\"/lib\"))\n}\n\n# Setters and Getters ----------\n\n#' @title Sets the model name\n#' @description  Set the name of the model currently instantiated.\n#' \n#' @param s The model name\n#' \n#' @export\nsetId<- function(s) {\n  assign(\"pkg.id\", s, pkg.globals)      \n}\n\n#' @title Gets the model name\n#' @description  Provides the name of the model currently instantiated.\n#' \n#' @export\ngetId<- function() {\n  return(get(\"pkg.id\", pkg.globals))\n}\n\n#' @title Sets Repast randomSeed name\n#' @description Configures a non-default value for Repast randomSeed\n#' parameter name.\n#' \n#' @param k The string with an alternative name for randomSeed \n#' \n#' @export\nsetKeyRandom<- function(k){\n  assign(\"pkg.randomSeed\",k, pkg.globals)\n}\n\n#' @title Gets Repast randomSeed name\n#' @description Returns the Repast randomSeed parameter name.\n#' \n#' @return A string value holding the randomSeed name.\n#' \n#' @export\ngetKeyRandom<- function() {\n  return(get(\"pkg.randomSeed\", pkg.globals))\n}\n\n#' @title Sets output directory\n#' \n#' @description Configure the desired directoy to save model \n#' output data.\n#' \n#' @param s The full path for output directory\n#' \n#' @export\nsetOutputDir<- function(s) {\n  assign(\"pkg.outputdir\", s, pkg.globals)    \n}\n\n#' @title Gets output directory\n#' \n#' @description Returns the value of module variable for \n#' storing the current output directory. \n#' \n#' @export\ngetOutputDir<- function() {\n  return(get(\"pkg.outputdir\", pkg.globals))\n}\n\n#' @title getLogDir()\n#' \n#' @description Returns the value for log directory\n#' \n#' @export\ngetLogDir<- function() {\n  return(paste0(getOutputDir(),\"Log/\"))\n}\n\n#' @title Create output directory\n#' \n#' @description A simple function to make a directory to save the \n#' model's data.\n#' \n#' @details Create the, if required, the directory to save the \n#' output data generate by the model. It is intended for internal \n#' use.\n#' \n#' @export \ncreateOutputDir<- function() {\n  lambda<- function(d) {\n    if(!dir.exists(d)) {\n      dir.create(d)\n    }\n  }\n  \n  ## -- Create required directories\n  lambda(getOutputDir())\n  lambda(getLogDir())\n}\n\n\n\n# Set the directory where repast model is installed\nsetBaseDir<- function(s) {\n  assign(\"pkg.basedir\", s, pkg.globals)  \n}\n\n# Gets the directory where repast model is installed\ngetBaseDir<- function() {\n  return(get(\"pkg.basedir\", pkg.globals))  \n}\n\n# Sets the directory where repast model is installed which normally\n# is a subdirectory below installation base directory\nsetModelDir<- function(s) {\n  assign(\"pkg.modeldir\", s, pkg.globals)  \n}\n\n# Sets the directory where repast model is installed which normally\n# is a subdirectory below installation base directory\ngetModelDir<- function() {\n  return(get(\"pkg.modeldir\", pkg.globals))  \n}\n\n# Sets the model's scenario directory\nsetScenarioDir<- function(s) {\n  assign(\"pkg.scenariodir\", s, pkg.globals)  \n}\n\n# Gets the model's scenario directory\ngetScenarioDir<- function() {\n  return(get(\"pkg.scenariodir\", pkg.globals))  \n}\n\n# Sets the model's lib directory\nsetModelLibDir<- function(s) {\n  assign(\"pkg.modellibdir\", s, pkg.globals)  \n}\n\n# Gets the model's lib directory\ngetModelLibDir<- function() {\n  return(get(\"pkg.modellibdir\", pkg.globals))  \n}\n\n# Traverse the lib dir to build up the classpath\nrepastlibs<- function() {\n  libdir<- simphonylib()\n  for(d in dir(libdir)) {\n    # On bin dir we expect unpackaged class files\n    bin<- paste0(libdir,paste0(d,\"/bin\"))\n    lib<- paste0(libdir,paste0(d,\"/lib\"))\n    # adding the bin dir to rjava classpath\n    .jaddClassPath(bin)\n    \n    repastjars(paste0(libdir,d))\n    repastjars(lib)\n    repastjars(getModelLibDir())\n  }\n}\n\n# Search for jar files inside lib dir and then add it to classpath\nrepastjars<- function(lib) {\n  jars<- dir(lib,pattern=\"*.jar\")\n  for(j in jars) {\n    jar<- paste0(paste0(lib,\"/\"),j)\n    # adding jar file to classpath\n    .jaddClassPath(jar)\n  }\n}\n\n\n# ----- Exposed package API functions\n\n\n#' @title jvm.set_parameters\n#' \n#' @description Configures the jvm parameters\n#' \n#' @details Set the underlying parameters for java virtual machine. The default \n#' values are \"-server -Xms512m -Xmx1024m\". These defaults can be changed \n#' to fit the model requirements.\n#' \n#' @param s The paramter string to be passed to the underlying JVM \n#' \n#' @examples \\dontrun{\n#'    jvm.set_parameters(\"-server -Xms512m -Xmx2048m\")}\n#'    \n#' @export \njvm.set_parameters<- function(s) {\n  assign(\"pkg.java.parameters\", s, pkg.globals)  \n}\n\n#' @title jvm.get_parameters\n#' \n#' @description Returns the current java virtual machine parameters\n#' \n#' @return A string with JVM parameters. \n#' \n#' @export\njvm.get_parameters<- function() {\n  return(get(\"pkg.java.parameters\", pkg.globals))  \n}\n\n#' @title Init R/JVM environment\n#' \n#' @description Initialize rJava and repast environment with classpath. This function\n#' is called internally and it is not meant to be used directlly.\n#' \n#' @details The default parameters can be changed as needed calling the \n#' primitive \\code{\\link{jvm.set_parameters}} befor instantiating the model \n#' engine.\n#' \n#' @examples \\dontrun{\n#'      jvm.init()}\n#' \n#' @references\n#' [1] rJava: Low-Level R to Java Interface. Low-level interface to Java VM \n#' very much like .C/.Call and friends. Allows creation of objects, \n#' calling methods and accessing fields.\n#' \n#' @import rJava\njvm.init<- function() {\n  # The default parameters can be changed as needed\n  .jinit(parameters= jvm.get_parameters() )\n  .jaddClassPath(enginejar())\n  .jaddClassPath(paste0(getModelDir(),\"/bin\"))\n  # ----- Repast base libraries\n  repastlibs()\n}\n\n#' @title jvm.setOut\n#' \n#' @description Set the System.out filed to a file\n#' \n#' @param f The output file name\n#' \n#' @examples \\dontrun{\n#'    jvm.setOut(\"/tmp/SysteOut.log\")}\n#'    \n#' @import rJava\n#' \n#' @export \njvm.setOut<- function(f) {\n  ## -- Create the output dir if required\n  createOutputDir()\n  \n  my.f<- paste0(getLogDir(),f)\n  ## -- Java calls to redirect the output to a file\n  obj.fos<- new(J(\"java.io.FileOutputStream\"),my.f)\n  obj.ps<- new(J(\"java.io.PrintStream\"),obj.fos)\n  .jcall(\"java/lang/System\",\"V\", \"setOut\",obj.ps)    \n}\n\n#' @title jvm.resetOut\n#' \n#' @description Reset the System.out filed value to console output\n#' \n#' @examples \\dontrun{\n#'    jvm.resetOut()}\n#'    \n#' @import rJava\n#' \n#' @export \njvm.resetOut<- function() {\n  obj.os<- .jfield(\"java/io/FileDescriptor\", name=\"out\")\n  obj.fos<- new(J(\"java.io.FileOutputStream\"),obj.os)\n  obj.ps<- new(J(\"java.io.PrintStream\"),obj.fos)\n  .jcall(\"java/lang/System\",\"V\", \"setOut\",obj.ps)    \n}\n\n# ----- Wrapper functions for Engine class method calls\n\n\n#' @title Engine\n#' \n#' @description Creates an instance of Engine\n#' \n#' @details This function creates an instance of Repast model wrapper \n#' class. Before invoking the function Engine, make sure that \n#' environment was correctly initialized.\n#' \n#' @return An onject instance of Engine class\n#' \n#' @export\nEngine<- function() {\n  return(new(J(engineclazz())))\n}\n\n#' @title Engine.LoadModel\n#' \n#' @description Loads the model's scenario files\n#' \n#' @details This function loads the scenario of a Repast Model and \n#' initialize de model.\n#' \n#' @param e An engine object instance\n#' @param f The full path of scenario directory \n#' \n#' @export \nEngine.LoadModel<- function(e,f) {\n  .jcall(e,\"V\", \"LoadModel\",f)  \n}\n\n#' @title Engine.SetAggregateDataSet\n#' \n#' @description Sets the model's dataset\n#' \n#' @details Configure a dataset with the desired output values \n#' to be \"drained\" by the function Engine.GetModelOutput. \n#' \n#' @param e An engine object instance\n#' @param k The repast model's data set name\n#' \n#' @examples \\dontrun{\n#'    d<- \"C:/usr/models/your-model-directory\"\n#'    m<- Model(d)\n#'    setAggregateDataSet(m,\"dataset-name\")}\n#'    \n#' @export\nEngine.SetAggregateDataSet<- function(e,k) {\n  .jcall(e,\"V\",\"ModelDataSet\",k)\n}\n\n#' @title Engine.getParameterNames\n#' \n#' @description Get the parameter names\n#' \n#' @details Returns the names of all declared model's parameters in\n#' the parameter.xml file in the scenario directory.\n#' \n#' @param e An engine object instance\n#' \n#' @return A collection of parameter names\n#' \n#' @export\nEngine.getParameterNames<- function(e) {\n  names<- .jcall(e,\"[S\",\"getParameterNames\")\n  return(names)\n} \n\n#' @title Engine.getParameter\n#' \n#' @description The function gets the value of model \n#' parameter \\code{k} as java.lang.Object\n#' \n#' @param e An engine object instance\n#' @param k The parameter name\n#' \n#' @return The parameter value\n#' \n#' @export\nEngine.getParameter<- function(e,k) {\n  v<- .jcall(e,\"Ljava/lang/Object;\",\"getParameter\",k)\n  return(v)\n}\n\n#' @title Engine.getParameterType\n#' \n#' @description Returns the declared type of a Repast \n#' model parameter\n#' \n#' @param e An engine object instance\n#' @param k The parameter name\n#' \n#' @return The parameter type string\n#' \n#' @export \nEngine.getParameterType<- function(e,k) {\n  v<- .jcall(e,\"Ljava/lang/String;\",\"getParameterType\",k)\n}\n\n#' @title Engine.getParameterAsString \n#' \n#' @description Get the value of model parameter \\code{k} \n#' as \\code{java.lang.String}\n#' \n#' @param e An engine object instance\n#' @param k The parameter name\n#' \n#' @return The parameter value as string\n#' \n#' @export\nEngine.getParameterAsString<- function(e,k) {\n  v<- .jcall(e,\"Ljava/lang/String;\",\"getParameterAsString\",k)\n  return(v)\n}\n\n#' @title Engine.getParameterAsNumber\n#' \n#' @description Get the value of model parameter \n#' \\code{k} as \\code{java.lang.Number}\n#' \n#' @param e An engine object instance\n#' @param k The parameter name\n#' \n#' @return The parmeter value as number\n#' \n#' @export\nEngine.getParameterAsNumber<- function(e,k) {\n  v<- .jcall(e,\"Ljava/lang/Number;\",\"getParameterAsNumber\",k)\n  return(v)\n}\n\n#' @title Engine.getParameterAsDouble\n#' \n#' @description Get the value of model parameter \\code{k} as \\code{java.lang.Double}\n#' \n#' @param e An engine object instance\n#' @param k The parameter name\n#' \n#' @return The parmeter value as double\n#' \n#' @export\nEngine.getParameterAsDouble<- function(e,k) {\n  v<- .jcall(e,\"D\",\"getParameterAsDouble\",k)\n  return(v)\n}\n\n#' @title Engine.setParameter\n#' \n#' @description Set the value of model parameter \n#' \n#' @param e An engine object instance\n#' @param k The parameter name\n#' @param v The parameter value\n#' \n#' @export\nEngine.setParameter<- function(e,k,v) {\n  # Map the R type system to java object\n  switch(Engine.getParameterType(e,k),\n         java.lang.String = {\n           value<- new(J(\"java.lang.String\"), as.character(v))  \n         },\n         \n         double = {\n          value<- new(J(\"java.lang.Double\"), as.double(v))\n         },\n         \n         int = {\n           value<- new(J(\"java.lang.Integer\"), as.integer(v))\n         },\n         \n         boolean = {\n           value<- new(J(\"java.lang.Boolean\"), as.logical(v))\n         })\n  # Invoke the setParamter method\n  .jcall(e,\"V\",\"setParameter\",k,value)\n}\n\n#' @title Engine.endAt\n#' \n#' @description Configure the maximun simulated time for \n#' the current model run\n#' \n#' @param e An engine object instance\n#' @param v The number of Repast time ticks \n#' \n#' @export\nEngine.endAt<- function(e,v) {\n  .jcall(e,\"V\",\"endAt\",v)\n}\n\n#' @title Returns the model id\n#' \n#' @description This function provides a wrapper to the method getId() \n#' from repast context. The id is basically a String with the currently \n#' instantiated model name.\n#' \n#' @param e An engine object instance\n#' \n#' @export\nEngine.getId<- function(e) {\n  id<- .jcall(e,\"S\",\"getId\")\n  if(nchar(id) == 0) stop(\"Model not initilized.\")\n  return(id)\n}\n\n#' @title Engine.RunModel\n#' \n#' @description Performs the execution of Repast model\n#' \n#' @param e An engine object instance\n#' \n#' @export\nEngine.RunModel<- function(e) {\n  .jcall(e,\"V\",\"RunModel\")\n}\n\n#' @title Engine.GetModelOutput\n#' \n#' @description Gets the model output data as a CSV String array. \n#' Calls the engine method GetModelOutput to drain model output\n#' data.\n#' \n#' @param e An engine object instance\n#' \n#' @return An array of strings containing the model's output\n#' \n#' @examples \\dontrun{\n#'    d<- \"c:/usr/models/your-model-directory\"\n#'    m<- Model(d)\n#'    csv<- Engine.GetModelOutput(m)}\n#' @importFrom utils read.csv\n#' @export\nEngine.GetModelOutput<- function(e) {\n  .jcall(e,\"[S\",\"GetModelOutput\")\n}\n\n#' @title Engine.Finish\n#' \n#' @description Performs a cleanup on a engine instance.Finalize \n#' and destroy repast controller data.\n#' \n#' @param e An engine object instance\n#' \n#' @export\nEngine.Finish<- function(e) {\n  .jcall(e,\"V\",\"cleanUpBatch\")\n}\n\n#' @title Set the log level to INFO\n#' \n#' @description Configures the underlying logging system\n#' \n#' @export\nLogger.setLevelInfo<- function() {\n  logger<- J(\"org.haldane.rrepast.RepastEngineLogger\")\n  .jcall(logger,\"V\",\"setLevelInfo\")\n}\n\n#' @title Set the log level to WARNING\n#' \n#' @description Configures the underlying logging system\n#' \n#' @export\nLogger.setLevelWarning<- function() {\n  logger<- J(\"org.haldane.rrepast.RepastEngineLogger\")\n  .jcall(logger,\"V\",\"setLevelWarning\")\n}\n\n#' @title ShowModelPaths\n#' \n#' @description Prints the paths. Shows the directories \n#' currently used to load model scenario and lib. The output of \n#' this function is informational only and can be used to check \n#' whether model data is being loaded properly from \n#' correct locations.\n#' \n#' @examples \\dontrun{\n#'    ShowModelPaths()}\n#'    \n#' @export\nShowModelPaths<- function() {\n  print(paste(\"Install dir.= \",getBaseDir()))\n  print(paste(\"Model dir...= \",getModelDir()))\n  print(paste(\"Scenario dir= \",getScenarioDir()))\n  print(paste(\"Model lib...= \",getModelLibDir()))\n}\n\n#' @title ShowClassPath\n#' \n#' @description Shows the current classpath\n#' \n#' @return the current setting of JVM classpath\n#' \n#' @examples \\dontrun{\n#'    ShowClassPath()}\n#'    \n#' @export\nShowClassPath<- function() {\n  .jclassPath()\n}\n\n### --- Progress Bar functions\n\n#' @title PB.set\n#' \n#' @description  Ses the progress bar descriptor\n#' \n#' @param obj -- The progress bar descriptor\n#' \n#' @export\nPB.set<- function(obj) {\n  assign(\"pkg.progressbar\", obj, pkg.globals)      \n}\n\n#' @title PB.get\n#' \n#' @description  Gets the the progress bar descriptor\n#' \n#' @export\nPB.get<- function() {\n  return(get(\"pkg.progressbar\", pkg.globals))\n}\n\n#' @title PB.enable\n#' \n#' @description  Enables the progress bar visualization\n#' \n#' @export\nPB.enable<- function() {\n  assign(\"pkg.progressbar.enabled\", TRUE, pkg.globals)      \n}\n\n#' @title PB.disable\n#' \n#' @description  Disable the progress bar visualization\n#' \n#' @export\nPB.disable<- function() {\n  assign(\"pkg.progressbar.enabled\", FALSE, pkg.globals)      \n}\n\n#' @title PB.isEnabled\n#' \n#' @description Returns the global value indicating if progress bar \n#' is enabled.\n#' \n#' @return Boolean TRUE if progress bar must be shown\n#' \n#' @export\nPB.isEnabled<- function() {\n  return(get(\"pkg.progressbar.enabled\", pkg.globals))\n}\n\n#' @title PB.init\n#' \n#' @description Initialize progress bar for model\n#' execution.\n#' \n#' @param psets -- The total number of paramter sets being simulated\n#' @param replications -- The number of replications per simulation round\n#' \n#' @importFrom utils setTxtProgressBar txtProgressBar\n#' \n#' @export\nPB.init<- function(psets, replications) {\n  \n  ## -- Check if init function has already been called from RunExperiment\n  if(length(grep(\"(RunExperiment\\\\s*\\\\()|(Run\\\\s*\\\\()\",sys.calls())) == 2) {\n    ##print(grep(\"(RunExperiment\\\\s*\\\\()|(Run\\\\s*\\\\()\",sys.calls(),value=TRUE))  \n    return()\n  }\n  \n  ## -- print(grep(\"(RunExperiment\\\\s*\\\\()|(Run\\\\s*\\\\()\",sys.calls(),value=TRUE))  \n  ## -- print(\"PB.init\")\n  \n  if(PB.isEnabled()) {\n    total<- psets * replications\n    pbar<- txtProgressBar(min = 0, max = total, style = 3)\n    pbar$pset<- 1\n    pbar$replications<- replications\n    PB.set(pbar)  \n  }\n  return(sys.calls())\n}\n\n#' @title PB.close\n#' \n#' @description Close the progress bar descriptor\n#' \n#' @export\nPB.close<- function() {\n  ## -- Check if init function has already been called from RunExperiment\n  if(length(grep(\"(RunExperiment\\\\s*\\\\()|(Run\\\\s*\\\\()\",sys.calls())) == 2) {\n    return()\n  }\n  \n  if(PB.isEnabled()) {\n    pbar<- PB.get()\n    if(!is.null(pbar)) {\n      close(pbar)\n      PB.set(NULL)  \n    } else {\n      stop(\"Progress bar has not been initialized!\")\n    }\n  }\n}\n\n#' @title PB.pset\n#' \n#' @description Update pset value\n#' \n#' @param v The current parameter set being simulated\n#' \n#' @export\nPB.pset<- function(v) {\n  if(PB.isEnabled()) {\n    pbar<- PB.get()\n    if(!is.null(pbar)) {\n      pbar$pset<- v\n      PB.set(pbar)  \n    }  else {\n      stop(\"Progress bar has not been initialized!\")\n    }\n  }\n}\n\n#' @title PB.update\n#' \n#' @description Update progress bar\n#' \n#' @param r The current replication number\n#' \n#' @importFrom utils setTxtProgressBar txtProgressBar\n#' \n#' @export\nPB.update<- function(r) {\n  if(PB.isEnabled()) {\n    pbar<- PB.get()\n    if(!is.null(pbar)) {\n      setTxtProgressBar(pbar, (pbar$pset-1)*pbar$replications + r)\n\n    }  else {\n      stop(\"Progress bar has not been initialized!\")\n    }\n  }\n}\n\n#' @title The easy API for model initilization\n#' \n#' @description Instantiate a repast model from the model dir without\n#' loading the scenario file.\n#' \n#' @details This is the entry point for model execution. Typically \n#' any model execution will start with this function which encapsulates \n#' all low level calls for model initialization. In order to perform \n#' simulations with repast from R code only \\code{Model} and a \n#' few more function calls are required: \\code{\\link{Load}}, \n#' \\code{\\link{Run}}. Finally the output of model is managed with \n#' functions \\code{\\link{GetResults}} and \\code{\\link{SaveSimulationData}}.\n#' \n#' @param modeldir The installation directory of some repast model\n#' @param maxtime The total simulated time\n#' @param dataset The name of any model aggregate dataset\n#' @param load If true instantiate model and load scenario\n#' \n#' @return Returns the instance of repast model\n#' @examples \\dontrun{\n#'    d<- \"C:/usr/models/your-model-directory\"\n#'    m<- Model(d)}\n#'    \n#' @references\n#' [1] North, M.J., N.T. Collier, and J.R. Vos, \"Experiences Creating Three Implementations of the Repast Agent Modeling Toolkit,\" ACM Transactions\n#' on Modeling and Computer Simulation, Vol. 16, Issue 1, pp. 1-25, ACM,\n#' New York, New York, USA (January 2006).\n#' @export\nModel<- function(modeldir=\"\",maxtime=300,dataset=\"none\", load=FALSE) {\n  if(dir.exists(modeldir)) {\n    # Configure all required directory based on their default locations\n    configModelDirs(modeldir)\n    \n    # Initilialized JVM\n    # Setup classpath inferring default values from modeldir\n    jvm.init()\n    \n    # Creating an engine instance\n    e<- Engine()\n    \n    # Configure the total amount of time to be simulated\n    Engine.endAt(e,maxtime)\n    \n    # Configure the dataset\n    Engine.SetAggregateDataSet(e,dataset)\n    \n    if(load == TRUE) {\n      Load(e)\n    }\n    \n    return(e)\n  } else {\n    stop(paste0(\"The model directory does not exist: \", modeldir))\n  }\n}\n\n#' @title The Scenario loader\n#' \n#' @description Loads the model's scenario. This function must be \n#' called before running the model.\n#' \n#' @examples \\dontrun{\n#'    d<- \"C:/usr/models/your-model-directory\"\n#'    m<- Model(d)\n#'    Load(m)}\n#' \n#' @param e An engine object instance\n#' \n#' @export\nLoad<- function(e) {\n  Engine.LoadModel(e,getScenarioDir())\n  setId(Engine.getId(e))\n}\n\n#' @title Run simulations\n#' \n#' @description This function executes the time steps of an \n#' instantiated model. The number of replications of model \n#' runs can be specified by the function parameter. The seed \n#' parameter may be omitted and will be generated internally. \n#' If provided, the seed collection, must contain the same \n#' number of \\code{r} parameter. \n#'\n#' @param e An engine object instance\n#' @param r The number of experiment replications\n#' @param seed The random seed collection\n#' \n#' @return The model output dataset\n#' \n#' @examples \\dontrun{\n#'    d<- \"C:/usr/models/your-model-directory\"\n#'    m<- Model(d)\n#'    Load(m)\n#'    Run(m,r=2) # or Run(m,r=2,seed=c(1,2))}\n#'    \n#' @importFrom stats runif\n#' @export\nRun<- function(e,r=1,seed=c()) {\n  # The default behaviour is if seed set was\n  # not provided generate a suitable set of \n  # random seeds for the number of replications.\n  if(length(seed) == 0) {\n    seed= runif(r,-10^8,10^8)  \n  } else if(length(seed) != r) {\n    stop(\"The provided set of random numbers doesn't match replications!\")\n  }\n  \n  # Gets the current set of parameters\n  p<- GetSimulationParameters(e)\n  \n  # Clear result repository\n  ClearResults()\n  \n  SetResultsParameters(p)\n  \n  ## --- Progress Bar initialization\n  PB.init(1, r)\n  \n  results<- c()\n  \n  for(i in 1:r) {\n    ## --- Setting the random seed for experiment replication\n    Engine.setParameter(e,getKeyRandom(),as.integer(seed[i]))\n\n    ## --- Pass the control to Repast to run simulation      \n    Engine.RunModel(e)\n\n    data<- GetOutput(e)\n    \n    ## --- Just for debug: print(paste0(\"run= \", i, \" / rows=\", nrow(data)))\n    \n    # Sets the current run number\n    data$run<- i\n    \n    # Add replication data \n    AddResults(data)\n    \n    results<- rbind(results,data)\n    \n    # Update progress bar\n    PB.update(i)\n  }\n  ## --- Progress Bar clean up\n  PB.close()\n  \n  return(results)\n}\n\n#' @title Run an experimental setup\n#' \n#' @description Run the model multiple times for different parameters\n#' given by design matrix function parameter.\n#' \n#' @details The FUN function must return zero for perfect fit and values \n#' greater than zero otherwise.\n#'\n#' @param e An engine object instance\n#' @param r The number of experiment replications\n#' @param design The desing matrix holding parameter sampling\n#' @param FUN THe calibration function.\n#' \n#' @examples \\dontrun{\n#'    my.cost<- function(params, results) { # your best fit calculation, being 0 the best metric.  }\n#'    d<- \"c:/usr/models/your-model-directory\"\n#'    m<- Model(d,dataset=\"ds::Output\")\n#'    Load(m)\n#'    f<- AddFactor(name=\"cyclePoint\",min=40,max=90)\n#'    f<- AddFactor(factors=f, name=\"conjugationCost\",min=1,max=80)\n#'    d<- LatinHypercube(factors=f)\n#'    p<- GetSimulationParameters(e)\n#'    exp.design<- BuildParameterSet(d,p)\n#'    v<- RunExperiment(e,r=1,exp.design,my.cost) }\n#'    \n#' @return A list with output and dataset\n#' \n#' @export\nRunExperiment<- function(e, r=1, design, FUN) {\n  paramset<- c()\n  output<- c()\n  dataset<- c()\n  \n  psets<- nrow(design)\n  \n  ## --- Progress Bar initialization\n  PB.init(psets, r)\n  \n  for(i in 1:psets) {\n    d<- design[i,]\n    \n    # -- Set parameters for next model 'Run'\n    SetSimulationParameters(e, d)\n    \n    # -- Update progress bar pset value\n    PB.pset(i)\n    \n    # -- Run model with current parameter set\n    Run(e,r)\n    \n    results<- GetResults()\n    \n    # -- The user provided calibration function.\n    # -- Calibration function must return 0 for perfect fit between \n    # -- observed and experimental data.\n    calibration<- FUN(d,results)\n    \n    if(is.null(calibration)) {\n      stop(\"Invalid user provided calibration function!\")  \n    }\n    \n    # -- The 'pset' is the paramter set id\n    pset<- i\n    \n    paramset<- rbind(paramset,cbind(pset,d))\n    output<- rbind(output,cbind(pset,calibration))\n    dataset<- rbind(dataset,cbind(pset,results))\n  }\n  \n  ## --- Progress Bar clean up\n  PB.close()\n  \n  return(list(paramset=paramset, output=output, dataset=dataset))\n}\n\n#' @title Helper function to get experiment \\code{paramset}\n#' \n#' @description The RunExperiment function returns a list holding\n#' the \\code{paramset}, \\code{output} and \\code{dataset} collection.\n#' The \\code{paramset} collection contains the parameters used for \n#' running the experimental setup. The \\code{output} has the results \n#' from user provided calibration function. The \\code{dataset} \n#' collection has the raw output of 'Repast' aggregated dataset.\n#' \n#' @examples \\dontrun{\n#'    d<- \"C:/usr/models/your-model-directory\"\n#'    m<- Model(d)\n#'    ...\n#'    e<- RunExperiment(e,r=1,exp.design,my.cost)\n#'    p<- getExperimentParamSet(e)}\n#' \n#' @param e The experiement object returned by \\code{\\link{RunExperiment}} \n#' \n#' @return The reference to \\code{output} container.\n#' @export\ngetExperimentParamSet<- function(e) {\n  v<- e$paramset\n  return(v)\n}\n\n#' @title Helper function to get experiment \\code{output}\n#' \n#' @description The RunExperiment function returns a list holding\n#' the \\code{paramset}, \\code{output} and \\code{dataset} collection.\n#' The \\code{paramset} collection contains the parameters used for \n#' running the experimental setup. The \\code{output} has the results \n#' from user provided calibration function. The \\code{dataset} \n#' collection has the raw output of 'Repast' aggregated dataset.\n#' \n#' @param e The experiement object returned by \\code{\\link{RunExperiment}} \n#' \n#' @return The reference to \\code{output} container.\n#' @export\ngetExperimentOutput<- function(e) {\n  v<- e$output\n  return(v)\n}\n\n#' @title Helper function to get experiment \\code{dataset}\n#' \n#' @description The RunExperiment function returns a list holding\n#' the \\code{paramset}, \\code{output} and \\code{dataset} collection.\n#' The \\code{paramset} collection contains the parameters used for \n#' running the experimental setup. The \\code{output} has the results \n#' from user provided calibration function. The \\code{dataset} \n#' collection has the raw output of 'Repast' aggregated dataset.\n#' \n#' @param e The experiement object returned by \\code{\\link{RunExperiment}} \n#' \n#' @return The reference to \\code{dataset} container.\n#' @export\ngetExperimentDataset<- function(e) {\n  v<- e$dataset\n  return(v)\n}\n\n#' @title Gets the output\n#' \n#' @description  Returns the results of a model a data.frame from the last\n#' RUN. Should be used only if model replication is equal to 1,\n#' otherwise GetResults must be used.\n#' \n#' @param e An engine object instance\n#' \n#' @return Returns a data.frame with output data\n#' \n#' @examples \\dontrun{\n#'    d<- \"C:/usr/models/your-model-directory\"\n#'    m<- Model(d)\n#'    ...\n#'    data<- GetOutput(m)}\n#'    \n#' @importFrom utils read.csv\n#' @export\nGetOutput<- function(e) {\n  c<- textConnection(Engine.GetModelOutput(e))\n  read.csv(c)\n}\n\n#' @title Set parameters for running model\n#' \n#' @description Modify the repast model parameters with \n#' values provided in parameter 'p' which is a data frame\n#' with just one row.\n#' \n#' @param e An engine object instance\n#' @param p A data frame with simulation parameters\n#' \n#' @export\nSetSimulationParameters<- function(e, p) {\n  if(is.null(e)) {\n    stop(\"Engine object is null!\")  \n  }\n\n  for(key in names(p)) {\n    value<- p[1,key]\n    if(is.factor(value)) {\n      value<- levels(value)\n    } \n    \n    ## Modify the default set of parameters\n    SetSimulationParameter(e, key, value)\n  }\n}\n\n#' @title SetSimulationParameter \n#' \n#' @description Modify model's default parameter collection\n#' \n#' @param e An engine object instance\n#' @param key The paramter name\n#' @param value The parameter value\n#' \n#' @export\nSetSimulationParameter<- function(e, key, value) {\n  if(is.null(e)) {\n    stop(\"Engine object is null!\")  \n  }\n  \n  keys<- names(GetSimulationParameters(e))\n  \n  # Verify that \"key\" is a valid model parameter\n  if(key %in% keys) {\n  # Try to coerce the value to a type for safety\n    switch(typeof(value),\n      double = {\n        #print(paste0(\"double\", key,\"<- \",value))\n        value<- as.double(value)\n      },\n      \n      integer = { \n        #print(paste0(\"integer\", key,\"<- \",value))\n        value<- as.integer(value)\n      },\n      \n      character = { \n         #print(paste0(\"character\", key,\"<- \",value))\n         value<- as.character(value)\n       })\n    Engine.setParameter(e,key,value)          \n  }\n}\n\n#' @title Gets the simulation parameters\n#' \n#' @description Returns a dataframe with the current set of input \n#' parameters for the last model run.\n#' \n#' @param e An engine object instance\n#' \n#' @return A data frame with simulation parameters\n#'\n#' @export\nGetSimulationParameters<- function(e) {\n  keys<- \"\"\n  values<- \"\"\n  names<- Engine.getParameterNames(e)\n  for(n in names) {\n    v<- Engine.getParameterAsString(e,n)\n    if(nchar(keys) == 0){\n      keys<- n\n      values<- v\n    } else {\n      keys<- paste0(keys,\",\",n)\n      values<- paste0(values,\",\",v)\n    }\n  }\n  b<- rbind(keys,values)\n  c<- textConnection(b)\n  read.csv(c)\n} \n\n#' @title Clear the results data.frame\n#' \n#' @description This function is called automatically every\n#' time Run method is called.\n#'\n#' @export\nClearResults<- function() {\n  assign(\"pkg.results\", data.frame(), pkg.globals)   \n  assign(\"pkg.parameters\", data.frame(), pkg.globals)   \n}\n\n#' Returns the model results\n#'\n#' @export\nGetResults<- function() {\n  return(get(\"pkg.results\", pkg.globals))\n}\n\n#' Stores a data.frame \n#' \n#' @param d A data frame containing one replication data\n#'\n#' @export\nSetResults<- function(d) {\n  assign(\"pkg.results\", d, pkg.globals)     \n}\n\n#' @title Concatenate results of multiple runs\n#' \n#' @description This function stores the output \n#' of the last model execution and it is intended \n#' to be used internally.\n#' \n#' @param d A data frame containing one replication data\n#'\n#' @export\nAddResults<- function(d) {\n  r<- GetResults()\n  SetResults(rbind(r,d))\n}\n\n#' @title Gets the parameters\n#' \n#' @description Returns the current set of paramters used \n#' for the last model run.\n#'\n#' @return A data.frame with parameters of the model.\n#'\n#' @export\nGetResultsParameters<- function() {\n  return(get(\"pkg.parameters\", pkg.globals))\n}\n\n#' @title Sets the parameters\n#' \n#' @description Save the current set of paramters used \n#' for the last model run.\n#' \n#' @param d A data.frame with parameter values\n#'\n#' @export\nSetResultsParameters<- function(d) {\n  assign(\"pkg.parameters\", d, pkg.globals)     \n}\n\n#' @title Saving simulation output\n#' \n#' @description Saves the simulation results of last call to Run(e)\n#' function.\n#' \n#' @details The model must have been initialized or user must call \n#' \\code{setId} explicitelly.\n#' \n#' @param as The desired output type, must be csv or xls\n#' @param experiment The experiment output\n#' \n#' @return The id of saved data\n#' \n#' @importFrom xlsx write.xlsx\n#' @importFrom digest digest\n#' @importFrom utils write.csv\n#' @export\nSaveSimulationData<- function(as=\"csv\", experiment=NULL) {\n  # Creating output dir if needed\n  createOutputDir()\n  filename<- getId()\n  if(is.na(filename)) {\n    stop(\"Model was not initialized correctly!\")\n  }\n  \n  paramset<- NULL\n  output<- NULL\n  dataset<- NULL\n  \n  if(!is.null(experiment)) {\n    paramset<- getExperimentParamSet(experiment)\n    output<- getExperimentOutput(experiment)\n    dataset<- getExperimentDataset(experiment)\n    \n  } else {\n    # The parameters of current simultation output\n    paramset<- GetResultsParameters()\n    \n    # The results of simulation run\n    dataset<- GetResults()  \n  }\n  \n  \n  \n  hash <- digest(Sys.time(), algo=\"crc32\")\n  f0<- paste0(getOutputDir(),tolower(filename),\"-paramset-\",hash)\n  f1<- paste0(getOutputDir(),tolower(filename),\"-output-\",hash)\n  f2<- paste0(getOutputDir(),tolower(filename),\"-dataset-\",hash)\n  \n  switch(as,\n         csv = {\n           f0<- paste0(f0,\".csv\")\n           f1<- paste0(f1,\".csv\")\n           f2<- paste0(f2,\".csv\")\n           write.csv(paramset, f0, row.names=FALSE)\n           if(!is.null(output)) {\n             write.csv(output, f1, row.names=FALSE)  \n           }\n           write.csv(dataset, f2, row.names=FALSE)\n         },\n         xls = { \n           f0<- paste0(f0,\".xlsx\")\n           f1<- paste0(f1,\".xlsx\")\n           f2<- paste0(f2,\".xlsx\")\n           \n           write.xlsx(paramset, f0)\n           if(!is.null(output)) {\n             write.xlsx(output, f1)\n           }\n           write.xlsx(dataset, f0)\n         })\n  return(hash)\n}\n\n##\n## ----- Below sensitivity analysis functions\n##\n\n#' @title Adds a paramter to factor collection\n#' \n#' @description Builds up the factor collection.\n#' \n#' @param factors The current factor collection\n#' @param lambda The function to apply FUN(p,min,max)\n#' @param name The name of factor\n#' @param min The minimun of parameter p\n#' @param max The maximun of parameter p\n#' \n#' @examples \\dontrun{\n#'    f<- AddFactor(name=\"Age\",min=20,max=60)\n#'    f<- AddFactor(factors=f, name=\"Weight\",min=50,max=120)}\n#' \n#' @return The collection of created factors\n#'\n#' @export\nAddFactor<- function(factors=c(), lambda=\"qunif\",name, min, max) {\n  if(max < min) {\n    stop(\"Invalid factor range!\")\n  }\n  \n  # if parameter already existe replace the current value\n  rrow<- c(lambda=lambda,name=name,min=min,max=max)\n  rownames(rrow)<- NULL\n  if(length(factors) > 0 && factors[,\"name\"] == name) {\n    i<- which(factors[,\"name\"] == name)  \n    factors[i,]<- c(rrow)\n  } else {\n    factors<- rbind(factors,c(rrow))\n  }\n  return(factors)\n}\n\n#' @title Get the number of factors\n#' \n#' @description Returns the total number of factors\n#' \n#' @param factors A collection of factors created with AddFactor\n#' \n#' @return The number of parameters in factors collection\n#'\n#' @export\nGetFactorsSize<- function(factors) {\n  n<- nrow(factors)\n  if(is.null(n)) n<- 0\n  return(n)\n}\n\n#' @title Corrects the LHS design matrix\n#' \n#' @description Correct the LHS sampling matrix for a \n#' specific range applying the lambda function. The default\n#' value of 'lambda' is 'qunif'.\n#' \n#' @param design The LHS design matrix\n#' @param factors THe collection of factors\n#' \n#' @return The corrected design matrix\n#'\n#' @export\nApplyFactorRange<- function(design, factors) {\n  k<- GetFactorsSize(factors)\n  d<- sapply(1:k, function(p) {match.fun(factors[p,\"lambda\"])(design[,p],as.numeric(factors[p,\"min\"]),as.numeric(factors[p,\"max\"]))})\n  \n  if(is.null(nrow(d))) {\n    ## --- Handle the case where sample size is 1\n    d<- as.data.frame(t(d))  \n  } else {\n    ## --- Handle the case where sample size > 1\n    d<- as.data.frame(d)  \n  }\n\n  names(d)<- factors[,\"name\"]\n  return(d)\n}\n\n#' @title Builds the simulation parameter set\n#' \n#' @description Merges the design matrix with parameters which \n#' will be keep fixed along simulation runs.\n#' \n#' @param design The experimental desing matrix for at least one factor\n#' @param parameters All parameters of the repast model.\n#' \n#' @return A data frame holding all parameters required for running the model\n#' \n#' @examples \\dontrun{\n#'    modeldir<- \"c:/usr/models/BactoSim(HaldaneEngine-1.0)\"\n#'    e<- Model(modeldir=modeldir,dataset=\"ds::Output\")\n#'    Load(e)\n#'    \n#'    f<- AddFactor(name=\"cyclePoint\",min=40,max=90)\n#     f<- AddFactor(factors=f, name=\"conjugationCost\",min=1,max=80)\n#'    \n#'    p<- GetSimulationParameters(e)\n#'    \n#'    d<- LatinHypercube(factors=f)\n#'    \n#'    p1<- BuildParameterSet(d,p)}\n#' \n#' @export\nBuildParameterSet<- function(design, parameters) {\n  v<- as.data.frame(design)\n  tmp.p<- parameters\n  for(n in names(v)) {\n    # Drop parameters columns which are in design matrix\n    tmp.p[n]<- NULL\n  }\n\n  # Now join two data frames\n  for(i in 1:length(names(tmp.p))) {\n    v<- cbind(tmp.p[i],v)      \n  }\n  return(v)\n}\n\n#' @title SequenceItem\n#' \n#' @description Generate a sequence from min to max using an increment\n#' based on the number of of elements in v\n#' \n#' @param v A column of n x k design matrix\n#' @param min The lower boundary of range\n#' @param max The uper boundary of range\n#' \n#' @return A sequence between min and max value\n#' \n#' @export\nSequenceItem<- function(v,min,max) {\n  n<- length(v)\n  delta<- (max-min)/(n-1)\n  return(seq(min,max,delta))\n}\n\n#' @title df2matrix\n#' \n#' @description This function converts data frames to matrix data type.\n#' \n#' @param d The data frame\n#' @param n The column names to be converted. Null for all data frame columns\n#' \n#' @return The data frame converted to a matrix\n#' \n#' @export\ndf2matrix<- function(d,n=c()) {\n  if(length(n) == 0) {\n    n<- names(d)\n  }\n  m<- c()\n  for(k in n) {\n    m<- cbind(m,as.matrix(d[,k]))\n  }\n  colnames(m)<- n\n  return(m)\n}\n\n#' @title dfsumcol\n#' \n#' @description Sum data frame columns but tho\n#' \n#' @param d The data frame \n#' @param lst Skip columns included. Sum columns NOT included \n#' @param invert Sum only the columns included in \\code{lst}\n#' \n#' @return The original data frame with a new column (sum) holding the sum \n#' \n#' @export\ndfsumcol<- function(d,lst=c(),invert=FALSE) {\n  v<- as.data.frame(d)\n  s<- NULL\n  \n  op<- \"!\"\n  if(invert) {\n    identity<- function(x) {x}\n    op<- \"identity\"\n  }\n\n  for(key in colnames(v)) {\n    if(match.fun(FUN=op)(toupper(key) %in% toupper(lst))) {\n      if(is.null(s)){\n        s<- v[, key]\n      } else {\n        s<- s + v[, key]\n      }\n    }\n  }  \n  v$total<- s\n  \n  ## Return the same type of original data\n  if(is.matrix(d)) {\n    v<- as.matrix(v)  \n  }\n  \n  return(v)\n}\n\n#' @title dffilterby\n#' \n#' @description Selects a subset of a data frame, filtering by \n#' column values.\n#' \n#' @param d The data frame holding data to be filtered\n#' @param key The column name for selection valuas\n#' @param values The collection of values used to filter the data set\n#' \n#' @return The filtered data set\n#' \n#' @export\ndffilterby<- function(d, key, values=c()) {\n  d<- as.data.frame(d)\n  \n  o<- c()\n  for(v in values) {\n    o<- rbind(o,d[d[,colnames(d) == key] %in% v,])    \n  }\n  return(o)\n}\n\n#' @title dfround\n#' \n#' @description Round all numeric columns of a data frame\n#' \n#' @param d The data frame \n#' @param p The number of decimal digits to be keept\n#' \n#' @return A data frame with rounded columns\n#' \n#' @export\ndfround<- function(d, p) {\n  return(sapply(d[,sapply(d,is.numeric)],round,digits=p))\n}\n\n# ----- DoE - Design of Experiments  \n# ----- AoE - Analysis of Experimental Data\n\n#' @title AoE.RMSD\n#' \n#' @description  A simple Root-Mean-Square Deviation \n#' calculation.\n#' \n#' @param xs The simulated data set\n#' @param xe The experimental data set\n#' \n#' @return The RMSD value for provided datasets\n#' @export\nAoE.RMSD<- function(xs, xe) {\n  return(sqrt(mean((xs - xe)^2, na.rm = TRUE)))\n}\n\n#' @title AoE.MAE\n#' \n#' @description Calculates the average-error\n#' magnitude (MAE)\n#' \n#' @param xs The simulated data set\n#' @param xe The experimental data set\n#' \n#' @return The MAE value for provided datasets\n#' @export\nAoE.MAE<- function(xs, xe) {\n  return(mean((abs(xs - xe)), na.rm = TRUE))\n}\n\n#' @title AoE.NRMSD\n#' \n#' @description  A simple Normalized Root-Mean-Square \n#' Deviation calculation using max and min values.\n#' NRMSD = RMSD(x) / (max(x) - min(x))\n#' \n#' @param xs The simulated data set\n#' @param xe The experimental data set\n#' \n#' @return The NRRMSD value for provided datasets\n#' \n#' @export\nAoE.NRMSD<- function(xs, xe) {\n  ##divisor<- abs(max(xe,na.rm = TRUE) - min(xe,na.rm = TRUE))\n  return(sqrt(mean((xs - xe)^2, na.rm = TRUE))/mean(xe, na.rm = TRUE))\n}\n\n#' @title AoE.CoV\n#' \n#' @description A simple funcion for calculate the \n#' Coefficient of Variation\n#' \n#' @param d The data collection\n#' @return The coefficient of variation for data\n#' \n#' @importFrom stats sd\n#' \n#' @export\nAoE.CoV<- function(d) {\n  return((sd(d,na.rm = TRUE)/mean(d,na.rm = TRUE)) * 100)\n}\n\n#' @title AoE.ColumnCoV\n#' \n#' @description This function Calculates the relative squared \n#' deviation (RSD or CoV) for an used provided column name \\code{key}\n#' in the parameter \\code{dataset}. \n#' \n#' @param dataset A model output dataset\n#' @param key Column name from output dataset\n#' \n#' @return A data frame with Coefficient of variations\n#' \n#' @export\nAoE.ColumnCoV<- function(dataset, key) {\n  m.run<- dataset$run\n  if(is.null(m.run)) {\n    stop(\"The dataset is not an instance of model output!\")\n  }\n  \n  result<- c()\n  m.max<- max(m.run)\n  \n  for(i in 1:m.max) {\n    m.data<- with(dataset,dataset[run %in% seq(1,i), key])\n    result<- rbind(result,cbind(i, AoE.CoV(m.data)))\n  }\n  result<- as.data.frame(result)\n  names(result)<- c(\"sample\",\"RSD\")\n  return(result)\n}\n\n#' @title AoE.Stability\n#' \n#' @description This function verifies the stability \n#' of CoV for all columns given by parameter \\code{keys}\n#' or all dataset columns if keys is empty.\n#' \n#' @param dataset A model output dataset\n#' @param keys A list of column names\n#' \n#' @return A data frame with Coefficient of variations\n#' \n#' @export\nAoE.Stability<- function(dataset, keys=c()) {\n  if(length(keys) == 0) {\n    keys<- setdiff(names(dataset), c(\"pset\",\"random_seed\",\"run\",\"Time\"))   \n  }\n  \n  results<- c()\n  for(k in keys) {\n    v<- AoE.ColumnCoV(dataset,k)\n    v$group<- k\n    results<- rbind(results,v)\n  }\n  return(results)\n}\n  \n#' @title AoE.Base\n#' \n#' @description The Design Of Experiments Base function\n#' \n#' @param m The base design matrix\n#' @param factors A subset of model parameters\n#' @param fun The function which will be applied to m\n#'\n#' @return The design matrix\n#'\n#' @export\nAoE.Base<- function(m, factors=c(), fun=NULL) {\n  k<- GetFactorsSize(factors)\n  if(k == 0) {\n    stop(\"Empty factor collection!\")\n  }\n  \n  tmp.factors<- factors\n  if(!is.null(fun)) {\n    tmp.factors[,\"lambda\"]<- fun  \n  }\n  \n  # --- Apply the desired range\n  design<- ApplyFactorRange(m, tmp.factors)\n  return(design)\n}\n\n#' @title AoE.LatinHypercube \n#' \n#' @description Generate a LHS sample for model parameters\n#' \n#' @details Generate the LHS sampling for evaluating \n#' the parameters of a model.\n#' \n#' @param n The number of samples\n#' @param factors The model's parameters which will be evaluated\n#' \n#' @return The LHS design matrix for provided parameters\n#' \n#' @examples \\dontrun{\n#'  f<- AddFactor(name=\"cyclePoint\",min=40,max=90)\n#'  f<- AddFactor(factors=f, name=\"conjugationCost\",min=1,max=80)\n#'  d<- DoE.LatinHypercube(2,f)}\n#' \n#' @importFrom lhs randomLHS\n#' @export\nAoE.LatinHypercube<- function(n=10, factors=c()) {\n  k<- GetFactorsSize(factors)\n  \n  # --- Generate design matrix\n  design<- AoE.Base(randomLHS(n, k), factors)\n  return(design)\n}\n\n#' @title AoE.FullFactorial design generator\n#' \n#' @description Generate a Full Factorial sampling for evaluating \n#' the parameters of a model.\n#' \n#' @param n The number of samples\n#' @param factors The model's parameters which will be evaluated\n#' \n#' @return The Full Factorial design matrix for provided parameters\n#' \n#' @examples \\dontrun{\n#'  f<- AddFactor(name=\"cyclePoint\",min=40,max=90)\n#'  f<- AddFactor(factors=f, name=\"conjugationCost\",min=1,max=80)\n#'  d<- AoE.FullFactorial(2,f)}\n#' \n#' @export\nAoE.FullFactorial<- function(n=10, factors=c()) {\n  k<- GetFactorsSize(factors)\n  \n  # --- calculate n for the aproximate number of samples\n  n<- round(n^(1/k))\n  \n  # --- Generate design matrix\n  design<- AoE.Base(matrix(nrow = n, ncol = k, seq(1,n)), factors, \"SequenceItem\")\n  design<-  expand.grid(design)\n  return(design)\n}\n\n#' @title AoE.RandomSampling experiment desing generator\n#' \n#' @description Generate a Simple Random Sampling experiment design\n#' matrix.\n#' \n#' @param n The number of samples\n#' @param factors The model's parameters which will be evaluated\n#' \n#' @return The random sampling design matrix \n#' \n#' @examples \\dontrun{\n#'  f<- AddFactor(name=\"cyclePoint\",min=40,max=90)\n#'  f<- AddFactor(factors=f, name=\"conjugationCost\",min=1,max=80)\n#'  d<- AoE.RandomSampling(2,f)}\n#' \n#' @export\nAoE.RandomSampling<- function(n=10, factors=c()) {\n  k<- GetFactorsSize(factors)\n  m<- c()\n  for(i in 1:k) {\n    m<- cbind(m,runif(n))  \n  }\n  design<- AoE.Base(m, factors)\n  return(design)\n}\n\n#' @title AoE.Morris \n#' \n#' @description This is a wrapper for performing Morris's  screening\n#' method on repast models. We rely on morris method from sensitivity \n#' package.\n#' \n#' @param k The factors for morris screening.\n#' @param p The number of levels for the model's factors.\n#' @param r Repetitions. The number of random sampling points of Morris Method.\n#' \n#' @references Gilles Pujol, Bertrand Iooss, Alexandre Janon with contributions from Sebastien Da Veiga, Jana Fruth,\n#' Laurent Gilquin, Joseph Guillaume, Loic Le Gratiet, Paul Lemaitre, Bernardo Ramos and Taieb Touati (2015).\n#' sensitivity: Sensitivity Analysis. R package version 1.11.1.\n#' https://CRAN.R-project.org/package=sensitivity\n#' \n#' @importFrom sensitivity morris\n#' @export\nAoE.Morris<- function(k=c(),p=5,r=4) {\n  \n  k.v<- GetFactorsSize(k)\n  if(k.v == 0) {\n    stop(\"Empty factor collection!\")\n  }\n  \n  p.min<- as.numeric(k[,\"min\"])\n  p.max<- as.numeric(k[,\"max\"])\n  p.design<- list(type = \"oat\", levels = p, grid.jump = ceiling(p/2))  \n  v<- morris(NULL, k[,\"name\"], r, p.design, p.min, p.max, scale=TRUE)\n  return(v)\n}\n\n#' @title AoE.GetMorrisOutput \n#' \n#' @description  Returns a dataframe holding the Morris \n#' result set\n#' \n#' @param obj A reference to a morris object instance\n#' \n#' @return The results of Morris method\n#' \n#' @importFrom stats sd\n#' @export\nAoE.GetMorrisOutput<- function(obj) {\n  mu <- apply(obj$ee, 2, mean)\n  mu.star <- apply(obj$ee, 2, function(x) mean(abs(x)))\n  sigma <- apply(obj$ee, 2, sd) \n  m<- t(rbind(mu,mu.star,sigma))\n  tmp<- as.data.frame(m,row.names=seq(1,nrow(m)))\n  tmp$group<- rownames(m)\n  return(tmp)\n}\n\n#' @title AoE.Sobol\n#' \n#' @description This is a wrapper for performing Global Sensitivity\n#' Analysis using the Sobol Method provided by sensitivity \n#' package.\n#' \n#' @details This function is not intended to be used directly from \n#' user programs.\n#' \n#' @references Gilles Pujol, Bertrand Iooss, Alexandre Janon with contributions from Sebastien Da Veiga, Jana Fruth,\n#' Laurent Gilquin, Joseph Guillaume, Loic Le Gratiet, Paul Lemaitre, Bernardo Ramos and Taieb Touati (2015).\n#' sensitivity: Sensitivity Analysis. R package version 1.11.1.\n#' https://CRAN.R-project.org/package=sensitivity\n#' \n#' @param n The number of samples\n#' @param factors The model's parameters which will be evaluated\n#' @param o Maximum order in the ANOVA decomposition\n#' @param nb Number of bootstrap replicates\n#' @param fun.doe The sampling function to be used for sobol method\n#' @param fun.sobol The sobol implementation\n#' \n#' \n#' @importFrom sensitivity sobol sobolmartinez\n#' @export\nAoE.Sobol<- function(n=100, factors=c(), o=2, nb=100, fun.doe=AoE.LatinHypercube, fun.sobol=sobolmartinez) {\n  p.x1<- fun.doe(n,factors)\n  p.x2<- fun.doe(n,factors)\n  v<- fun.sobol(model = NULL, X1 = p.x1,X2 = p.x2, order = o, nboot = nb) \n  return(v)\n}\n  \n##\n## ----- Below Plot functions\n##\n\n#' @title Plot stability of output\n#' \n#' @description Generate plot for visually access the stability of \n#' coefficient of variation as function of simulation sample size.\n#' \n#' @param obj An instance of Morris Object \\code{\\link{AoE.Morris}}\n#' @param title Chart title, may be null\n#' \n#' @return The resulting ggplot2 plot object\n#' \n#' @importFrom ggplot2 ggplot aes geom_point geom_line ggtitle labs geom_bar geom_errorbar\n#' @export\nPlot.Stability<- function(obj, title= NULL) {\n  \n  if(is.null(obj$RSD)) {\n    stop(\"Invalid object instance!\")\n  }\n  \n  d<- obj\n  \n  p<- ggplot(d, with(d,aes(sample, RSD))) \n  \n  p<- p + labs(y = expression(\"RSD\"))\n  p<- p + labs(x = expression(\"sample size\"))\n  \n  if(!is.null(title)) {\n    p<- p + ggtitle(title)\n  }\n  \n  p<- p + with(d,aes(shape = group)) \n  p<- p + geom_line( with(d,aes(colour = group)), size = 1)\n  \n  return(p)\n}\n\n#' @title Plot of Morris output\n#' \n#' @description Generate plot for Morris's screening method\n#' \n#' @param obj An instance of Morris Object \\code{\\link{AoE.Morris}}\n#' @param type The chart type (mu*sigma|musigma|mu*mu)\n#' @param title Chart title, may be null\n#' \n#' @return The resulting ggplot2 plot object\n#' \n#' @importFrom ggplot2 ggplot aes geom_point geom_line ggtitle labs geom_bar geom_errorbar\n#' @export\nPlot.Morris<- function(obj, type, title= NULL) {\n  # --- Check if we received a valid morris object\n  if(is.null(obj$call)) {\n    stop(\"Invalid Morris object instance!\")\n  }\n  \n  d<- AoE.GetMorrisOutput(obj)\n  \n  switch(type,\n    \"mu*sigma\" = { \n      p<- ggplot(d, with(d,aes(mu.star, sigma)))  \n      p<- p + labs(y = expression(sigma))\n      p<- p + labs(x = expression(paste(mu,\"*\")))\n    },\n    \n    \"musigma\" = { \n      p<- ggplot(d, with(d,aes(mu, sigma)))\n      p<- p + labs(y = expression(sigma))\n      p<- p + labs(x = expression(mu))\n    },\n    \n    \"mu*mu\" = {\n      p<- ggplot(d, with(d,aes(mu.star, mu)))\n      p<- p + labs(y = expression(mu))\n      p<- p + labs(x = expression(paste(mu,\"*\")))\n    },\n    \n    stop(\"Invalid chart type!\")\n  )\n  \n  if(!is.null(title)) {\n    p<- p + ggtitle(title)\n  }\n  \n  p<- p + with(d,aes(shape = group)) \n  p<- p + geom_point( with(d,aes(colour = group)), size = 4)\n  p<- p + geom_point(colour=\"grey90\", size = 1.5)\n  \n  return(p)\n}\n\n#' @title Plot of Sobol output\n#' \n#' @description Generate plot for Sobol's GSA\n#' \n#' @param obj An instance of Sobol Object \\code{\\link{AoE.Sobol}}\n#' @param type The chart type \n#' @param title Chart title, may be null\n#' \n#' @return The resulting ggplot2 plot object\n#' \n#' @importFrom ggplot2 ggplot aes geom_point geom_line ggtitle labs geom_bar geom_errorbar\n#' @export\nPlot.Sobol<- function(obj, type, title= NULL) {\n  # --- Check if we received a valid sobol object\n  if(is.null(obj$S)) {\n    stop(\"Invalid Sobol object instance!\")\n  }\n  \n  switch(type,\n         # --- First order indices\n         \"1\" = { \n           d<- obj$S\n           # --- Add the group column based on rownames\n           d$group<- rownames(obj$S)\n           \n           y.label<- labs(y = expression(S[i]))\n         },\n         # --- Total order indices\n         \"2\" = { \n           d<- obj$T\n           # --- Add the group column based on rownames\n           d$group<- rownames(obj$T)\n           \n           y.label<- labs(y = expression(S[Ti]))\n         },\n         \n         stop(\"Invalid chart type!\")\n  )\n  \n  # --- Create plot object\n  p<- ggplot(d, with(d,aes(group,original)))\n  p<- p + y.label\n  p<- p + labs(x = expression(paste(\"parameter\")))\n\n  ## --- p<- p + geom_bar(stat=\"identity\",aes(fill = group))\n  p<- p + geom_bar(stat=\"identity\")\n  p<- p + geom_errorbar( with(d, aes(ymin=`min. c.i.`, ymax=`max. c.i.`)), colour=\"black\", width=.1)\n  \n  if(!is.null(title)) {\n    p<- p + ggtitle(title)\n  }\n  \n  return(p)\n}\n \n#' @title Plot of calibration \n#' \n#' @description Generate plot for parameter sets \n#' providing best fit\n#' \n#' @param obj An instance of calibration Object\n#' @param key The column name\n#' @param title Chart title, may be null\n#' \n#' @return The resulting ggplot2 plot object\n#' \n#' @importFrom ggplot2 ggplot aes geom_point geom_line ggtitle labs geom_bar geom_errorbar\n#' @export\nPlot.Calibration<- function(obj, key, title= NULL) {\n  # --- Check if we received a valid sobol object\n  if(is.null(obj$pset)) {\n    stop(\"Invalid calibration object instance\")\n  }\n  \n  d<- obj\n  d$pset<- factor(d$pset, levels = d$pset)\n  \n  y.label<- labs(y = expression(\"Goodness of fit\"))\n\n  # --- Create plot object\n  p<- ggplot(d, with(d,aes(pset,d[,key])))\n  p<- p + y.label\n  p<- p + labs(x = expression(paste(\"Parameter set\")))\n  \n  ## --- p<- p + geom_bar(stat=\"identity\",aes(fill = group))\n  p<- p + geom_bar(stat=\"identity\")\n\n  if(!is.null(title)) {\n    p<- p + ggtitle(title)\n  }\n  \n  return(p)\n}\n\n##\n## ----- Below Easy Api Methods\n##\n\n#' @title Easy.getChart\n#' \n#' @description Returns the chart instance\n#' \n#' @param obj A reference to the output of Easy.Stability\n#' @param key The param name\n#' \n#' @return The plot instance\n#' @export\nEasy.getChart<- function(obj, key) {\n  if(is.null(obj$charts)) {\n    stop(\"Not an instance of Easy API result!\")\n  }\n  charts<- obj$charts\n  chart<- charts[charts[,1] ==  key,]\n  return(chart)\n}\n\n#' @title Easy API for output stability\n#' \n#' @description This functions run model several times in order to determine \n#' how many experiment replications are required for model's output being stable\n#' (i.e. the convergence of standard deviation)\n#' \n#' @param m.dir The installation directory of some repast model\n#' @param m.ds The name of any model aggregate dataset\n#' @param m.time The total simulated time\n#' @param parameters The factors or model's parameter list\n#' @param samples The number of factor samples.\n#' @param tries The number of experiment replications\n#' @param vars The model's output variables for compute CoV\n#' @param FUN The calibration function.\n#' \n#' @return A list with holding experimnt, object and charts \n#' \n#' @export\nEasy.Stability<- function(m.dir, m.ds, m.time=300, parameters, samples=1, tries=100, vars= c(), FUN) {\n  my.model<- Model(modeldir=m.dir,maxtime = m.time, dataset=m.ds)\n  Load(my.model)\n\n  ## --- Sample the parameter space\n  sampling<- AoE.RandomSampling(samples, parameters)\n  \n  ## --- Get the model declared paramters\n  parms<- GetSimulationParameters(my.model)\n  \n  ## --- Build the experimental parameter set\n  exp.design<- BuildParameterSet(sampling, parms)\n  \n  ## --- Run the experimental setup\n  exp<- RunExperiment(my.model,r=tries,exp.design,FUN)\n  \n  ## --- Get the raw data set for evaluate the Coefficient of Variation\n  d<- getExperimentDataset(exp)\n  \n  ## --- Calculate the coefficient of variation\n  rsd<- AoE.Stability(d, vars)\n  \n  charts<- c()\n  for(group in unique(rsd$group)) {\n    chart<- Plot.Stability(rsd[rsd$group == group, ],\"Simulation output stability\")  \n    charts<- rbind(charts, list(group=group,plot=chart))\n  }\n  \n  if(length(vars) != 0) {\n    chart<- Plot.Stability(rsd,\"Simulation output stability\")\n    charts<- rbind(charts, list(group=\"all\",plot=chart))\n  }\n  \n  results<- list(experiment=exp, object=rsd, charts=charts)\n  return(results)\n  \n}\n\n#' @title Easy API for Morris's screening method\n#' \n#' @description This functions wraps all calls to perform Morris method.\n#' \n#' @param m.dir The installation directory of some repast model\n#' @param m.ds The name of any model aggregate dataset\n#' @param m.time The total simulated time\n#' @param parameters The factors for morris screening.\n#' @param mo.p The number of levels for the model's factors.\n#' @param mo.r Repetitions. The number of random sampling points of Morris Method.\n#' @param exp.r The number of experiment replications\n#' @param FUN The calibration function.\n#' \n#' @return A list with holding experimnt, object and charts \n#' \n#' @importFrom sensitivity tell\n#' \n#' @export\nEasy.Morris<- function(m.dir, m.ds, m.time=300, parameters, mo.p, mo.r, exp.r, FUN) {\n  my.model<- Model(modeldir=m.dir,maxtime = m.time, dataset=m.ds)\n  Load(my.model)\n  \n  ## --- Create Morris object\n  v.morris<- AoE.Morris(parameters,p=mo.p,r=mo.r)\n  \n  ## --- Get the model declared paramters\n  parms<- GetSimulationParameters(my.model)\n  \n  ## --- Build the experimental parameter set\n  exp.design<- BuildParameterSet(v.morris$X,parms)\n  \n  ## --- Run the experimental setup\n  exp<- RunExperiment(my.model,r=exp.r,exp.design,FUN)\n  \n  charts<- c()\n  o<- getExperimentOutput(exp)\n  for(k in colnames(o)) {\n    if(k != \"pset\") {\n      m<- t(df2matrix(getExperimentOutput(exp),c(k)))\n      tell(v.morris,m)\n      \n      ## --- Plot Morris output\n      mustar<- Plot.Morris(v.morris,\"mu*sigma\", paste(\"criteria\",k))\n      musigma<- Plot.Morris(v.morris,\"musigma\", paste(\"criteria\",k))\n      mumu<- Plot.Morris(v.morris,\"mu*mu\", paste(\"criteria\",k))\n      charts<- rbind(charts,list(mu.star=mustar,mu=musigma,mumu=mumu))\n    } \n    ### ---> results<- list(experiment=exp, object=v.morris, charts=charts)\n  }\n  \n  results<- list(experiment=exp, object=v.morris, charts=charts)\n  return(results)\n}\n\n#' @title Easy API for Sobol's SA method\n#' \n#' @description This functions wraps all required calls to perform \n#' Sobol method for global sensitivity analysis.\n#' \n#' @param m.dir The installation directory of some repast model\n#' @param m.ds The name of any model aggregate dataset\n#' @param m.time The total simulated time\n#' @param parameters The input factors\n#' @param exp.n The experiment sample size\n#' @param exp.r The number of experiment replications\n#' @param bs.size The bootstrap sample size for sobol method\n#' @param FUN The calibration function.\n#' \n#' @return A list with holding experimnt, object and charts \n#' \n#' @importFrom sensitivity tell\n#' \n#' @export\nEasy.Sobol<- function(m.dir, m.ds, m.time=300, parameters,exp.n = 500, bs.size = 200, exp.r=1, FUN) {\n  ## --- Instantiate the model\n  my.model<- Model(modeldir=m.dir,maxtime = m.time, dataset=m.ds)\n  Load(my.model)\n  \n  ## --- Get the model declared paramters\n  parms<- GetSimulationParameters(my.model)\n  \n  ## --- Create a Sobol object\n  my.obj<- AoE.Sobol(n= exp.n, parameters, nb=bs.size)\n  \n  # Build the experimental parameter set\n  exp.design<- BuildParameterSet(my.obj$X,parms)\n  \n  ## --- Run the experimental setup\n  exp<- RunExperiment(my.model,r=exp.r,exp.design,FUN)\n  \n  charts<- c()\n  o<- getExperimentOutput(exp)\n  for(k in colnames(o)) {\n    if(k != \"pset\") {\n      m<- t(df2matrix(getExperimentOutput(exp),c(k)))\n      tell(my.obj,m)\n      \n      # -- First order indexes\n      chart_0<- Plot.Sobol(my.obj, 1, paste(\"Sobol indexes for\", k))\n      \n      # -- Total order indexes\n      chart_1<- Plot.Sobol(my.obj, 2, paste(\"Sobol indexes for\", k))\n      \n      charts<- rbind(charts,list(chart=chart_0))\n      charts<- rbind(charts,list(chart=chart_1))\n    } \n    ### ---> results<- list(experiment=exp, object=my.obj, charts=charts)\n  }\n  results<- list(experiment=exp, object=my.obj, charts=charts)\n  return(results)\n}\n\n#' @title Easy.Setup\n#' \n#' @description This function configures the deployment directory \n#' where logs and output dataset will be generated.  By default \n#' the deployment directory will be created under the model \n#' installation directory. The output generated by the Repast model \n#' will be redirected to the SystemOut.log file.  \n#' \n#' @details If the deployment directory is empty the installation \n#' directory given by the parameter \\code{model} is used instead as \n#' the base directory. The deployment directory is \\code{/rrepast-deployment/}.\n#' \n#' @param model The base directory where Repast model is installed.\n#' @param deployment The directory to save the output and logs.\n#' \n#' @export\nEasy.Setup<- function(model, deployment=c()){\n  \n  if(length(deployment) == 0) {\n    deployment<- paste0(model,\"/rrepast-deployment/\")\n  }\n  \n  setOutputDir(deployment)\n  \n  ## -- Create output dir if required\n  createOutputDir()\n  \n  jvm.setOut(\"SystemOut.log\")\n  PB.enable()\n}\n\n#' @title Easy.Calibration\n#' \n#' @description Search for the best set of parameters trying to \n#' minimize the calibration function provided by the user. The function \n#' has to operational models, the first based on the experimental setup \n#' where all parameters are defined a priori and the second using \n#' optimization techniques. Currently the only supported optimization \n#' technique is the particle swarm optimization.\n#' \n#' @param m.dir The installation directory of some repast model\n#' @param m.ds The name of any model aggregate dataset\n#' @param m.time The total simulated time\n#' @param parameters The input factors\n#' @param exp.n The experiment sample size\n#' @param exp.r The number of experiment replications\n#' @param smax The number of solutions to be generated\n#' @param design The sampling scheme [\"lhs\"|\"mcs\"|\"ffs\"]\n#' @param FUN The calibration function.\n#'\n#' @return A list with holding experiment, object and charts \n#' \n#' @examples \\dontrun{\n#'  my.cost<- function(params, results) {\n#'    criteria<- c()\n#'    Rate<- AoE.RMSD(results$X.Simulated,results$X.Experimental)\n#'    G<- AoE.RMSD(results$G.T.,52)\n#'    total<- Rate + G\n#'    criteria<- cbind(total,Rate,G)\n#'    return(criteria)\n#'  }\n#'  \n#'  Easy.Setup(\"/models/BactoSim\")\n#'  v<- Easy.Calibration(\"/models/BactoSim\",\"ds::Output\",360,\n#'                        f,exp.n = 1000, exp.r=1, smax=4, \n#'                        design=\"mcs\", my.cost)\n#'  \n#' }\n#' \n#' @export\nEasy.Calibration<- function(m.dir, m.ds, m.time=300, parameters, exp.n = 100, exp.r=1, smax=4, design=\"lhs\", FUN) {\n  ## --- Sample the parameter space\n  \n  method<- \"simple\"\n  switch(method,\n    simple = {\n      v<- simple.fitting(m.dir, m.ds, m.time, parameters, exp.n, exp.r, design , smax, FUN)      \n    }, \n    stop(\"Valid calibration methods are [simple|pso]\")\n  )\n  \n  return(v)\n}\n\n\n##\n## ----- Below calibration support methods\n##\n\n\n#' @title simple.fitting\n#' \n#' @description Simple calibration method. Run an experimental setup and select the \n#' the best results minimizing the calibration function\n#' \n#' @param m.dir The installation directory of some repast model\n#' @param m.ds The name of any model aggregate dataset\n#' @param m.time The total simulated time\n#' @param parameters The input factors\n#' @param samples The experiment sample size\n#' @param tries The number of experiment replications\n#' @param design The sampling scheme [\"lhs\"|\"mcs\"|\"ffs\"]\n#' @param smax The number of solutions to be generated\n#' @param objective The calibration function.\n#'\n#' @importFrom gridExtra ttheme_default tableGrob arrangeGrob\n#' @export\nsimple.fitting<- function(m.dir, m.ds, m.time=300, parameters, samples=100, tries=1, design=\"lhs\" , smax=4, objective) {\n  ## --- Instantiate the model\n  my.model<- Model(modeldir=m.dir,maxtime = m.time, dataset=m.ds,load = TRUE)\n  \n  \n  ## --- Sample the parameter space\n  switch(design,\n    lhs = {\n      sampling<- AoE.LatinHypercube(samples, parameters)  \n    },\n    \n    mcs = {\n      sampling<- AoE.RandomSampling(samples, parameters)\n    },\n    \n    ffs = {\n      sampling<- AoE.FullFactorial(samples, parameters)\n    },\n    \n    stop(\"Valid sampling types are [mcs|lhs|ffs]\")\n    \n  )\n         \n  \n  ## --- Get the model declared paramters\n  parms<- GetSimulationParameters(my.model)\n  \n  ## --- Build the experimental parameter set\n  exp.design<- BuildParameterSet(sampling, parms)\n  \n  ## --- Run the experimental setup\n  exp<- RunExperiment(my.model,r=tries,exp.design,objective)\n  \n  ## --- Add a totalization column\n  exp$output<- col.sum(exp$output)\n\n  tbl.theme<- ttheme_default(colhead=list(fg_params = list(parse=TRUE)))\n  \n  ##tmp<- c()\n  charts<- c()\n  obj<- c()\n  fittest.max<- smax \n  \n  o<- getExperimentOutput(exp)\n  for(k in colnames(o)) {\n    if(k != \"pset\") {\n      p<- getExperimentParamSet(exp)\n      best<- dffilterby(o,\"pset\",pick.fittest(o,goals=c(k),fittest.max)$pset)\n      chart<- Plot.Calibration(best,k,paste0(\"Best parameters for \", k))\n      \n      best.p<- dffilterby(p,\"pset\",pick.fittest(o,goals=c(k),fittest.max)$pset)\n      tbl.data<- best.p[,c(\"pset\",parameters[,\"name\"])]\n      tbl.data<- dfround(tbl.data,2)\n      tbl.table<- tableGrob(tbl.data, rows=NULL, theme= tbl.theme)\n      my.chart<- arrangeGrob(chart, tbl.table, nrow=2, as.table=TRUE, heights=c(3,1))\n      \n      charts<- rbind(charts,list(variable=k,both=my.chart,chart=chart,table=tbl.table))\n      obj<- rbind(obj,list(variable=k,parameters=best.p,objective=best))\n    }\n  }\n  \n  ###obj$data<- tmp\n  ###obj$keys<- unlist(obj$data[,\"variable\"])\n  ###obj$parameters<- function(k) {obj$data[(obj$data[,\"variable\"] == k),\"parameters\"][[1]]}\n  ###obj$objective<- function(k) {obj$data[(obj$data[,\"variable\"] == k),\"objective\"][[1]]}\n\n  results<- list(experiment=exp, object=obj, charts=charts)\n  return(results)\n}\n\n##\n## ----- Functions for accessing result object members\n##\n\n#' @title Results.GetExperiment\n#' \n#' @description Simplify the access to the experiment member\n#' \n#' @param obj An instance of the object returned by \\code{Easy} methods\n#' \n#' @return The experiment element inside results\n#' @export\nResults.GetExperiment<- function(obj) {\n  if(is.null(obj$experiment)) {\n    stop(\"Not an instance of Easy API result!\")\n  }\n  obj$experiment\n}\n\n#' @title Results.GetObject\n#' \n#' @description Simplify the access to the object member\n#' \n#' @param obj An instance of the object returned by \\code{Easy} methods\n#' \n#' @return The object element inside results\n#' @export\nResults.GetObject<- function(obj) {\n  if(is.null(obj$object)) {\n    stop(\"Not an instance of Easy API result!\")\n  }\n  obj$object\n}\n\n#' @title Results.GetCharts\n#' \n#' @description Simplify the access to the charts member\n#' \n#' @param obj An instance of the object returned by \\code{Easy} methods\n#' \n#' @return The charts element inside results\n#' @export\nResults.GetCharts<- function(obj) {\n  if(is.null(obj$charts)) {\n    stop(\"Not an instance of Easy API result!\")\n  }\n  obj$charts\n}\n\n#' @title Calibration.GetMemberKeys\n#' \n#' @description Gets the list of keys (the factor names)\n#' \n#' @param obj An instance of the object returned by \\code{Easy} methods\n#' \n#' @return The collection of keys\n#' @export\nCalibration.GetMemberKeys<- function(obj) {\n  if(!\"variable\" %in% colnames(obj)) {\n    stop(\"Not an instance of a Easy.Calibration return!\")\n  }\n  unlist(obj[,\"variable\"])\n}\n\n#' @title Calibration.GetMemberList\n#' \n#' @description Gets the member list value\n#' \n#' @param obj An instance of the object returned by \\code{Easy} methods\n#' @param key The key value\n#' @param name The column name \n#' \n#' @return The member list\n#' @export\nCalibration.GetMemberList<- function(obj, key, name) {\n  if(!\"variable\" %in% colnames(obj)) {\n    stop(\"Not an instance of a Easy.Calibration return!\")\n  }\n  obj[(obj[,\"variable\"] == key),name][[1]]\n}\n\n\n#' @title pick.fittest\n#' \n#' @description Choose the best solutions minimizing the objective function\n#' \n#' @param out The output data set holding the values of goals \n#' @param goals The column names which must be used as goal\n#' @param n The number of solutions\n#' \n#' @return The n rows holding the best results\n#' \n#' @export\npick.fittest<- function(out, goals=c(), n=4) {\n  out<- as.data.frame(out) \n  \n  ## -- Check if out was generated by RunExperiment\n  if(!\"pset\" %in% colnames(out)) {\n    stop(\"Invalid data set!\")  \n  }\n  \n  ## --- Adjusting defaults\n  n<- ifelse(n > nrow(out),nrow(out),n)\n  goals<- ifelse(length(goals) == 0,c(2),goals)\n  \n  out<- out[order(out[,goals]), ]\n  return(out[1:n,])\n}\n\n#' @title col.sum\n#' \n#' @description Sum all columns but one (pset) of a data frame\n#' \n#' @param d The data frame \n#' @param skip The columns which should not be included in the sum\n#' \n#' @return The original data frame with a new column (sum) holding the sum \n#' \n#' @export\ncol.sum<- function(d,skip=c()) {\n  v<- as.data.frame(d)\n  s<- NULL\n  \n  ## -- always skip pset\n  if(!\"pset\" %in% skip) {\n    skip<- c(\"pset\",skip)  \n  }\n  \n  ## -- always skip total\n  if(!\"total\" %in% skip) {\n    skip<- c(\"total\",skip)  \n  }\n    \n  v<- dfsumcol(v,skip)\n  \n  return(v)\n}\n",
    "created" : 1459456946900.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "133167152",
    "id" : "8F6F8BE",
    "lastKnownWriteTime" : 1468692187,
    "last_content_update" : 1468692187827,
    "path" : "~/R-Projects/rrepast/R/RRepast.R",
    "project_path" : "R/RRepast.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}