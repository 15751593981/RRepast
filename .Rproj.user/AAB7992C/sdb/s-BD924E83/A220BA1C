{
    "contents" : "##================================================================================\n## This file is part of the rrepast package - R/Repast interface API\n## \n## (C)2015 Antonio Prestes Garcia <@>\n## For license terms see DESCRIPTION and/or LICENSE\n##\n## $Id$\n##================================================================================\n\n\n# ------------------------------------------------------------\n# .onLoad, Hook for loading package namespace\n# \n# ------------------------------------------------------------\n.onLoad<- function(libname, pkgname) {\n  #packageStartupMessage(\"R/Repast: Integrating Repast Models into R\\n\")\n  assign(\"pkg.globals\", new.env(), envir=parent.env(environment()))\n  \n  # Internal variables\n  assign(\"pkg.basedir\", NA, pkg.globals)\n  assign(\"pkg.modeldir\", NA, pkg.globals)\n  assign(\"pkg.scenariodir\", NA, pkg.globals)\n  assign(\"pkg.modellibdir\", NA, pkg.globals)\n  assign(\"pkg.id\", NA, pkg.globals)\n  \n  # global simulation results\n  assign(\"pkg.parameters\", data.frame(), pkg.globals)\n  assign(\"pkg.results\", data.frame(), pkg.globals)\n  \n  # default values for model\n  assign(\"pkg.outputdir\",paste0(Sys.getenv(\"TMP\"),\"/repast-output/\"), pkg.globals)\n  assign(\"pkg.repastlibdir\", \"/repast.simphony/\", pkg.globals)\n  assign(\"pkg.java.parameters\",\"-server -Xms512m -Xmx1024m\", pkg.globals)\n  \n  # default key for Repast random seed \n  assign(\"pkg.randomSeed\",\"randomSeed\", pkg.globals)\n  \n  # The Random Seed. You may want to change this.\n  set.seed(exp(1)*10^6)\n  \n  # Define funcions which are not present in ond R versions\n  compatibility()\n}\n\n\n\n# ----- internal functions \n\n# Define some required functions when not available from current R version\ncompatibility<- function() {\n  if(getRversion() <= \"3.1\") {\n    # dir.exists function is only available from R 3.2\n    f<- function(d) {\n      cat(\"my dir.exists()\")\n      v<- file.info(d)$isdir\n      return(ifelse(is.na(v), FALSE, v))\n    }\n    \n    # This is a trick to get the reference to the current environment\n    e<- as.environment(environment(enginejar))\n    assign(\"dir.exists\", f, e, immediate = FALSE)\n  }\n}\n\n# Returns the wrapper classes jar file location. \nenginejar<- function() {\n\n  # Try to guess the rrepast-engine.jar location  \n  for(p in .libPaths()) {\n    f0<- paste0(p,\"/rrepast/java/rrepast-engine.jar\")\n    f1<- paste0(p,\"/rrepast/inst/java/rrepast-engine.jar\")\n    if(file.exists(f0)) {\n      f<- f0\n      break\n    } else if(file.exists(f1)) {\n        f<- f1\n        break\n    }\n  }\n  return(f)\n}\n\n# Return the name of repast engine class name. \nengineclazz<- function() {\n  return(\"org.haldane.rrepast.RepastEngine\")\n}\n\n# Returns the repast simphony library dir\nsimphonylib<- function() {\n  b<- get(\"pkg.basedir\", pkg.globals)\n  l<- get(\"pkg.repastlibdir\", pkg.globals)\n  return(paste0(b,l))\n}\n\n# Configure all model directories based on default installation values\nconfigModelDirs<- function(s) {\n  d<- basename(s)\n  setBaseDir(s)\n  setModelDir(paste0(paste0(s,\"/\"),d))\n  setScenarioDir(paste0(paste0(paste0(getModelDir(),\"/\"),d),\".rs\"))\n  setModelLibDir(paste0(getModelDir(),\"/lib\"))\n}\n\n# Setters and Getters ----------\n\n#' @title Sets the model name\n#' @description  Set the name of the model currently instantiated.\n#' \n#' @param s -- The model name\n#' \n#' @export\nsetId<- function(s) {\n  assign(\"pkg.id\", s, pkg.globals)      \n}\n\n#' @title Gets the model name\n#' @description  Provides the name of the model currently instantiated.\n#' \n#' @export\ngetId<- function() {\n  return(get(\"pkg.id\", pkg.globals))\n}\n\n#' @title Sets Repast randomSeed name\n#' @description Configures a non-default value for Repast randomSeed\n#' parameter name.\n#' \n#' @param k -- The string with an alternative name for randomSeed \n#' \n#' @export\nsetKeyRandom<- function(k){\n  assign(\"pkg.randomSeed\",k, pkg.globals)\n}\n\n#' @title Gets Repast randomSeed name\n#' @description Returns the Repast randomSeed parameter name.\n#' \n#' @return A string value holding the randomSeed name.\n#' \n#' @export\ngetKeyRandom<- function() {\n  return(get(\"pkg.randomSeed\", pkg.globals))\n}\n\n#' @title Sets output directory\n#' \n#' @description Configure the desired directoy to save model \n#' output data.\n#' \n#' @param s -- The full path for output directory\n#' \n#' @export\nsetOutputDir<- function(s) {\n  assign(\"pkg.outputdir\", s, pkg.globals)    \n}\n\n#' @title Gets output directory\n#' \n#' @description Returns the value of module variable for \n#' storing the current output directory. \n#' \n#' @export\ngetOutputDir<- function() {\n  return(get(\"pkg.outputdir\", pkg.globals))\n}\n\n#' @title Create output directory\n#' \n#' @description A simple function to make a directory to save the \n#' model's data.\n#' \n#' @details Create the, if required, the directory to save the \n#' output data generate by the model. It is intended for internal \n#' use.\n#' \n#' @export \ncreateOutputDir<- function() {\n  d<- getOutputDir()\n  if(!dir.exists(d)) {\n    dir.create(d)\n  }\n}\n\n# Set the directory where repast model is installed\nsetBaseDir<- function(s) {\n  assign(\"pkg.basedir\", s, pkg.globals)  \n}\n\n# Gets the directory where repast model is installed\ngetBaseDir<- function() {\n  return(get(\"pkg.basedir\", pkg.globals))  \n}\n\n# Sets the directory where repast model is installed which normally\n# is a subdirectory below installation base directory\nsetModelDir<- function(s) {\n  assign(\"pkg.modeldir\", s, pkg.globals)  \n}\n\n# Sets the directory where repast model is installed which normally\n# is a subdirectory below installation base directory\ngetModelDir<- function() {\n  return(get(\"pkg.modeldir\", pkg.globals))  \n}\n\n# Sets the model's scenario directory\nsetScenarioDir<- function(s) {\n  assign(\"pkg.scenariodir\", s, pkg.globals)  \n}\n\n# Gets the model's scenario directory\ngetScenarioDir<- function() {\n  return(get(\"pkg.scenariodir\", pkg.globals))  \n}\n\n# Sets the model's lib directory\nsetModelLibDir<- function(s) {\n  assign(\"pkg.modellibdir\", s, pkg.globals)  \n}\n\n# Gets the model's lib directory\ngetModelLibDir<- function() {\n  return(get(\"pkg.modellibdir\", pkg.globals))  \n}\n\n# Traverse the lib dir to build up the classpath\nrepastlibs<- function() {\n  libdir<- simphonylib()\n  for(d in dir(libdir)) {\n    # On bin dir we expect unpackaged class files\n    bin<- paste0(libdir,paste0(d,\"/bin\"))\n    lib<- paste0(libdir,paste0(d,\"/lib\"))\n    # adding the bin dir to rjava classpath\n    .jaddClassPath(bin)\n    \n    repastjars(paste0(libdir,d))\n    repastjars(lib)\n    repastjars(getModelLibDir())\n  }\n}\n\n# Search for jar files inside lib dir and then add it to classpath\nrepastjars<- function(lib) {\n  jars<- dir(lib,pattern=\"*.jar\")\n  for(j in jars) {\n    jar<- paste0(paste0(lib,\"/\"),j)\n    # adding jar file to classpath\n    .jaddClassPath(jar)\n  }\n}\n\n\n# ----- Exposed package API functions\n\n\n#' Configures the jvm parameters\n#' \n#' Set the underlying parameters for java virtual machine. The default \n#' values are \"-server -Xms512m -Xmx1024m\". These defaults can be changed \n#' to fit the model requirements.\n#' \n#' @param s -- The paramter string to be passed to the underlying JVM \n#' \n#' @examples \\dontrun{\n#'    jvm.set_parameters(\"-server -Xms512m -Xmx2048m\")}\n#'    \n#' @export \njvm.set_parameters<- function(s) {\n  assign(\"pkg.java.parameters\", s, pkg.globals)  \n}\n\n#' Gets the current java virtual machine parameters\n#' @return A string with JVM parameters. \n#' @export\njvm.get_parameters<- function() {\n  return(get(\"pkg.java.parameters\", pkg.globals))  \n}\n\n#' @title Init R/JVM environment\n#' \n#' @description Initialize rJava and repast environment with classpath. This function\n#' is called internally and it is not meant to be used directlly.\n#' \n#' @details The default parameters can be changed as needed calling the \n#' primitive \\code{\\link{jvm.set_parameters}} befor instantiating the model \n#' engine.\n#' \n#' @examples \\dontrun{\n#'      jvm.init()}\n#' \n#' @references\n#' [1] rJava: Low-Level R to Java Interface. Low-level interface to Java VM \n#' very much like .C/.Call and friends. Allows creation of objects, \n#' calling methods and accessing fields.\n#' @import rJava\njvm.init<- function() {\n  # The default parameters can be changed as needed\n  .jinit(parameters= jvm.get_parameters() )\n  .jaddClassPath(enginejar())\n  .jaddClassPath(paste0(getModelDir(),\"/bin\"))\n  # ----- Repast base libraries\n  repastlibs()\n}\n\n\n# ----- Wrapper functions for Engine class method calls\n\n\n#' Creates an instance of Engine\n#' \n#' This function creates an instance of Repast model wrapper \n#' class. Before invoking the function Engine, make sure that \n#' environment was correctly initialized.\n#' \n#' @return An onject instance of Engine class\n#' @export\nEngine<- function() {\n  return(new(J(engineclazz())))\n}\n\n#' Loads the scenario files\n#' \n#' This function loads the scenario of a Repast Model and \n#' initialize de model.\n#' \n#' @param e -- An engine object instance\n#' @param f -- The full path of scenario directory \n#' @export \nEngine.LoadModel<- function(e,f) {\n  .jcall(e,\"V\", \"LoadModel\",f)  \n}\n\n#' Sets the model's dataset\n#' \n#' Configure a dataset with the desired output values \n#' to be \"drained\" by the function Engine.GetModelOutput. \n#' \n#' @param e -- An engine object instance\n#' @param k -- The repast model's data set name\n#' @examples \\dontrun{\n#'    d<- \"C:/usr/models/your-model-directory\"\n#'    m<- Model(d)\n#'    setAggregateDataSet(m,\"dataset-name\")}\n#' @export\nEngine.SetAggregateDataSet<- function(e,k) {\n  .jcall(e,\"V\",\"ModelDataSet\",k)\n}\n\n#' Parameter names\n#' \n#' Returns the names of all declared model's parameters in\n#' the parameter.xml file in the scenario directory.\n#' \n#' @param e -- An engine object instance\n#' @export\nEngine.getParameterNames<- function(e) {\n  names<- .jcall(e,\"[S\",\"getParameterNames\")\n  return(names)\n} \n\n#' Get the value of model parameter s as java.lang.Object\n#' @param e -- An engine object instance\n#' @param k -- The parameter name\n#' @return The parameter value\n#' \n#' @export\nEngine.getParameter<- function(e,k) {\n  v<- .jcall(e,\"Ljava/lang/Object;\",\"getParameter\",k)\n  return(v)\n}\n\n#' Get the type of a model parameter\n#' @param e -- An engine object instance\n#' @param k -- The parameter name\n#' @return The paramter type\n#' \n#' @export \nEngine.getParameterType<- function(e,k) {\n  v<- .jcall(e,\"Ljava/lang/String;\",\"getParameterType\",k)\n}\n\n#' Get the value of model parameter s as java.lang.String\n#' @param e -- An engine object instance\n#' @param k -- The parameter name\n#' @export\nEngine.getParameterAsString<- function(e,k) {\n  v<- .jcall(e,\"Ljava/lang/String;\",\"getParameterAsString\",k)\n  return(v)\n}\n\n#' Get the value of model parameter s as java.lang.Number\n#' @param e -- An engine object instance\n#' @param k -- The parameter name\n#' @export\nEngine.getParameterAsNumber<- function(e,k) {\n  v<- .jcall(e,\"Ljava/lang/Number;\",\"getParameterAsNumber\",k)\n  return(v)\n}\n\n#' Get the value of model parameter s as java.lang.Double\n#' @param e -- An engine object instance\n#' @param k -- The parameter name\n#' @export\nEngine.getParameterAsDouble<- function(e,k) {\n  v<- .jcall(e,\"D\",\"getParameterAsDouble\",k)\n  return(v)\n}\n\n#' Set the value of model parameter \n#' @param e -- An engine object instance\n#' @param k -- The parameter name\n#' @param v -- The parameter value\n#' @export\nEngine.setParameter<- function(e,k,v) {\n  # Map the R type system to java object\n  switch(Engine.getParameterType(e,k),\n         java.lang.String = {\n           value<- new(J(\"java.lang.String\"), as.character(v))  \n         },\n         \n         double = {\n          value<- new(J(\"java.lang.Double\"), as.double(v))\n         },\n         \n         int = {\n           value<- new(J(\"java.lang.Integer\"), as.integer(v))\n         },\n         \n         boolean = {\n           value<- new(J(\"java.lang.Boolean\"), as.logical(v))\n         })\n  # Invoke the setParamter method\n  .jcall(e,\"V\",\"setParameter\",k,value)\n}\n\n#' Configure the maximun simulated time for the current model run\n#' @param e -- An engine object instance\n#' @param v -- The number of time ticks \n#' @export\nEngine.endAt<- function(e,v) {\n  .jcall(e,\"V\",\"endAt\",v)\n}\n\n#' @title Returns the model id\n#' @description This function provides a wrapper to the method getId() \n#' from repast context. The id is basically a String with the currently \n#' instantiated model name.\n#' @param e -- An engine object instance\n#' @export\nEngine.getId<- function(e) {\n  id<- .jcall(e,\"S\",\"getId\")\n  if(nchar(id) == 0) stop(\"Model not initilized.\")\n  return(id)\n}\n\n#' Run the model\n#' @param e -- An engine object instance\n#' @export\nEngine.RunModel<- function(e) {\n  .jcall(e,\"V\",\"RunModel\")\n}\n\n#' Gets the model output data as a CSV String array\n#' \n#' Call the engine method GetModelOutput to drain model output\n#' data.\n#' \n#' @param e -- An engine object instance\n#' @return An array of strings containing the model's output\n#' @examples \\dontrun{\n#'    d<- \"C:/usr/models/your-model-directory\"\n#'    m<- Model(d)\n#'    csv<- Engine.GetModelOutput(m)}\n#' @importFrom utils read.csv\n#' @export\nEngine.GetModelOutput<- function(e) {\n  .jcall(e,\"[S\",\"GetModelOutput\")\n}\n\n#' Performs a cleanup on engine instance.\n#' \n#' Finalize and destroy repast controller data.\n#' \n#' @param e -- An engine object instance\n#' @export\nEngine.Finish<- function(e) {\n  .jcall(e,\"V\",\"cleanUpBatch\")\n}\n\n#' @title Set the log level to INFO\n#' @description Configures the underlying logging system\n#' \n#' @export\nLogger.setLevelInfo<- function() {\n  logger<- J(\"org.haldane.rrepast.RepastEngineLogger\")\n  .jcall(logger,\"V\",\"setLevelInfo\")\n}\n\n#' @title Set the log level to WARNING\n#' @description Configures the underlying logging system\n#' \n#' @export\nLogger.setLevelWarning<- function() {\n  logger<- J(\"org.haldane.rrepast.RepastEngineLogger\")\n  .jcall(logger,\"V\",\"setLevelWarning\")\n}\n\n#' Prints the paths\n#' \n#' Shows the directories currently used to load model scenario and lib. \n#' This function is informational only and can be used to check whether \n#' model data is being loaded properly from correct locations.\n#' \n#' @examples \\dontrun{\n#'    ShowModelPaths()}\n#' @export\nShowModelPaths<- function() {\n  print(paste(\"Install dir.= \",getBaseDir()))\n  print(paste(\"Model dir...= \",getModelDir()))\n  print(paste(\"Scenario dir= \",getScenarioDir()))\n  print(paste(\"Model lib...= \",getModelLibDir()))\n}\n\n#' Java Classpath\n#' \n#' Returns the current setting of JVM classpath\n#' \n#' @examples \\dontrun{\n#'    ShowClassPath()}\n#' @export\nShowClassPath<- function() {\n  .jclassPath()\n}\n\n\n#' @title The easy API for model initilization\n#' \n#' @description Instantiate a repast model from the model dir without\n#' loading the scenario file.\n#' \n#' @details This is the entry point for model execution. Typically \n#' any model execution will start with this function which encapsulates \n#' all low level calls for model initialization. In order to perform \n#' simulations with repast from R code only \\code{Model} and a \n#' few more function calls are required: \\code{\\link{Load}}, \n#' \\code{\\link{Run}}. Finally the output of model is managed with \n#' functions \\code{\\link{GetResults}} and \\code{\\link{SaveSimulationData}}.\n#' \n#' @param modeldir The installation directory of some repast model\n#' @param maxtime The total simulated time\n#' @param dataset The name of any model aggregate dataset\n#' \n#' @return Returns the instance of repast model\n#' @examples \\dontrun{\n#'    d<- \"C:/usr/models/your-model-directory\"\n#'    m<- Model(d)}\n#'    \n#' @references\n#' [1] North, M.J., N.T. Collier, and J.R. Vos, \"Experiences Creating Three Implementations of the Repast Agent Modeling Toolkit,\" ACM Transactions\n#' on Modeling and Computer Simulation, Vol. 16, Issue 1, pp. 1-25, ACM,\n#' New York, New York, USA (January 2006).\n#' @export\nModel<- function(modeldir=\"\",maxtime=300,dataset=\"none\") {\n  if(dir.exists(modeldir)) {\n    # Configure all required directory based on their default locations\n    configModelDirs(modeldir)\n    \n    # Initilialized JVM\n    # Setup classpath inferring default values from modeldir\n    jvm.init()\n    \n    # Creating an engine instance\n    e<- Engine()\n    \n    # Configure the total amount of time to be simulated\n    Engine.endAt(e,maxtime)\n    \n    # Configure the dataset\n    Engine.SetAggregateDataSet(e,dataset)\n    \n    return(e)\n  } else {\n    stop(paste0(\"The model directory does not exist: \", modeldir))\n  }\n}\n\n#' @title The Scenario loader\n#' @description Loads the model's scenario. This function must be \n#' called before running the model.\n#' \n#' @examples \\dontrun{\n#'    d<- \"C:/usr/models/your-model-directory\"\n#'    m<- Model(d)\n#'    Load(m)}\n#' \n#' @param e -- An engine object instance\n#' \n#' @export\nLoad<- function(e) {\n  Engine.LoadModel(e,getScenarioDir())\n  setId(Engine.getId(e))\n}\n\n#' @title Run simulations\n#' @description This function executes the time steps of an \n#' instantiated model. The number of replications of model \n#' runs can be specified by the function parameter. The seed \n#' parameter may be omitted and will be generated internally. \n#' If provided, the seed collection, must contain the same \n#' number of 'r' parameter. \n#'\n#' @param e -- An engine object instance\n#' @param r -- The number of experiment replications\n#' @param seed - The random seed collection\n#' \n#' @examples \\dontrun{\n#'    d<- \"C:/usr/models/your-model-directory\"\n#'    m<- Model(d)\n#'    Load(m)\n#'    Run(m,r=2) # or Run(m,r=2,seed=c(1,2))}\n#'    \n#' @importFrom stats runif\n#' @export\nRun<- function(e,r=1,seed=c()) {\n  # The default behaviour is if seed set was\n  # not provided generate a suitable set of \n  # random seeds for the number of replications.\n  if(length(seed) == 0) {\n    seed= runif(r,-10^8,10^8)  \n  } else if(length(seed) != r) {\n    stop(\"The provided set of random numbers doesn't match replications!\")\n  }\n  \n  # Gets the current set of parameters\n  p<- GetSimulationParameters(e)\n  \n  # Clear result repository\n  ClearResults()\n  \n  SetResultsParameters(p)\n  \n  for(i in 1:r) {\n    # Setting the random seed for experiment replication\n    Engine.setParameter(e,getKeyRandom(),as.integer(seed[i]))\n    \n    Engine.RunModel(e)\n    data<- GetOutput(e)\n    print(paste0(\"run= \", i, \" / rows=\", nrow(data)))\n    # Sets the current run number\n    data$run<- i\n    \n    # Data data to replications\n    AddResults(data)\n  }\n}\n\n#' @title Run an experimental setup\n#' \n#' @description Run the model multiple times for different parameters\n#' given by design matrix function parameter.\n#' \n#' @details The FUN function must return zero for perfect fit and values \n#' greater than zero otherwise.\n#'\n#' @param e -- An engine object instance\n#' @param r -- The number of experiment replications\n#' @param design -- The desing matrix holding parameter sampling\n#' @param FUN -- THe calibration function.\n#' \n#' @examples \\dontrun{\n#'    my.cost<- function(params, results) { # your best fit calculation, being 0 the best metric.  }\n#'    d<- \"c:/usr/models/your-model-directory\"\n#'    m<- Model(d,dataset=\"ds::Output\")\n#'    Load(m)\n#'    f<- AddFactor(name=\"cyclePoint\",min=40,max=90)\n#'    f<- AddFactor(factors=f, name=\"conjugationCost\",min=1,max=80)\n#'    d<- LatinHypercube(factors=f)\n#'    p<- GetSimulationParameters(e)\n#'    exp.design<- BuildParameterSet(d,p)\n#'    v<- RunExperiment(e,r=1,exp.design,my.cost) }\n#'    \n#' @return A list with output and dataset\n#' \n#' @export\nRunExperiment<- function(e, r=1, design, FUN) {\n  paramset<- c()\n  output<- c()\n  dataset<- c()\n  \n  for(i in 1:nrow(design)) {\n    d<- design[i,]\n    \n    # -- Set parameters for next model 'Run'\n    SetSimulationParameters(e, d)\n    \n    # -- Run model with current parameter set\n    Run(e,r)\n    \n    results<- GetResults()\n    \n    # -- The user provided calibration function.\n    # -- Calibration function must return 0 for perfect fit between \n    # -- observed and experimental data.\n    calibration<- FUN(d,results)\n    \n    if(is.null(calibration)) {\n      stop(\"Invalid user provided calibration function!\")  \n    }\n    \n    # -- The 'pset' is the paramter set id\n    pset<- i\n    \n    paramset<- rbind(paramset,cbind(pset,d))\n    output<- rbind(output,cbind(pset,calibration))\n    dataset<- rbind(dataset,cbind(pset,results))\n  }\n  return(list(paramset=paramset, output=output, dataset=dataset))\n}\n\n#' @title Helper function to get experiment \\code{paramset}\n#' \n#' @description The RunExperiment function returns a list holding\n#' the \\code{paramset}, \\code{output} and \\code{dataset} collection.\n#' The \\code{paramset} collection contains the parameters used for \n#' running the experimental setup. The \\code{output} has the results \n#' from user provided calibration function. The \\code{dataset} \n#' collection has the raw output of 'Repast' aggregated dataset.\n#' \n#' @examples \\dontrun{\n#'    d<- \"C:/usr/models/your-model-directory\"\n#'    m<- Model(d)\n#'    ...\n#'    e<- RunExperiment(e,r=1,exp.design,my.cost)\n#'    p<- getExperimentParamSet(e)}\n#' \n#' @param e -- The experiement object returned by \\code{\\link{RunExperiment}} \n#' \n#' @return The reference to \\code{output} container.\n#' @export\ngetExperimentParamSet<- function(e) {\n  v<- e$paramset\n  return(v)\n}\n\n#' @title Helper function to get experiment \\code{output}\n#' \n#' @description The RunExperiment function returns a list holding\n#' the \\code{paramset}, \\code{output} and \\code{dataset} collection.\n#' The \\code{paramset} collection contains the parameters used for \n#' running the experimental setup. The \\code{output} has the results \n#' from user provided calibration function. The \\code{dataset} \n#' collection has the raw output of 'Repast' aggregated dataset.\n#' \n#' @param e -- The experiement object returned by \\code{\\link{RunExperiment}} \n#' \n#' @return The reference to \\code{output} container.\n#' @export\ngetExperimentOutput<- function(e) {\n  v<- e$output\n  return(v)\n}\n\n#' @title Helper function to get experiment \\code{dataset}\n#' \n#' @description The RunExperiment function returns a list holding\n#' the \\code{paramset}, \\code{output} and \\code{dataset} collection.\n#' The \\code{paramset} collection contains the parameters used for \n#' running the experimental setup. The \\code{output} has the results \n#' from user provided calibration function. The \\code{dataset} \n#' collection has the raw output of 'Repast' aggregated dataset.\n#' \n#' @param e -- The experiement object returned by \\code{\\link{RunExperiment}} \n#' \n#' @return The reference to \\code{dataset} container.\n#' @export\ngetExperimentDataset<- function(e) {\n  v<- e$dataset\n  return(v)\n}\n\n#' @title Gets the output\n#' \n#' @description  Returns the results of a model a data.frame from the last\n#' RUN. Should be used only if model replication is equal to 1,\n#' otherwise GetResults must be used.\n#' \n#' @param e -- An engine object instance\n#' @return Returns a data.frame with output data\n#' @examples \\dontrun{\n#'    d<- \"C:/usr/models/your-model-directory\"\n#'    m<- Model(d)\n#'    ...\n#'    data<- GetOutput(m)}\n#'    \n#' @importFrom utils read.csv\n#' @export\nGetOutput<- function(e) {\n  c<- textConnection(Engine.GetModelOutput(e))\n  read.csv(c)\n}\n\n#' @title Set parameters for running model\n#' \n#' @description Modify the repast model parameters with \n#' values provided in parameter 'p' which is a data frame\n#' with just one row.\n#' \n#' @param e -- An engine object instance\n#' @param p -- A data frame with simulation parameters\n#' @export\nSetSimulationParameters<- function(e, p) {\n  if(is.null(e)) {\n    stop(\"Engine object is null!\")  \n  }\n  \n  keys<- names(GetSimulationParameters(e))\n  \n  for(key in names(p)) {\n    value<- p[1,key]\n    if(is.factor(value)) {\n      value<- levels(value)\n    } \n    \n    # Verify that \"key\" is a valid model parameter\n    if(key %in% keys) {\n      # Try to coerce the value to a type for safety\n      switch(typeof(value),\n             double = {\n               #print(paste0(\"double\", key,\"<- \",value))\n               value<- as.double(value)\n             },\n             integer = { \n               #print(paste0(\"integer\", key,\"<- \",value))\n               value<- as.integer(value)\n             },\n             character = { \n               #print(paste0(\"character\", key,\"<- \",value))\n               value<- as.character(value)\n             })\n      Engine.setParameter(e,key,value)          \n    }\n  }\n}\n\n#' @title Gets the simulation parameters\n#' \n#' @description Returns a dataframe with the current set of input \n#' parameters for the last model run.\n#' \n#' @param e -- An engine object instance\n#' @return A data frame with simulation parameters\n#'\n#' @export\nGetSimulationParameters<- function(e) {\n  keys<- \"\"\n  values<- \"\"\n  names<- Engine.getParameterNames(e)\n  for(n in names) {\n    v<- Engine.getParameterAsString(e,n)\n    if(nchar(keys) == 0){\n      keys<- n\n      values<- v\n    } else {\n      keys<- paste0(keys,\",\",n)\n      values<- paste0(values,\",\",v)\n    }\n  }\n  b<- rbind(keys,values)\n  c<- textConnection(b)\n  read.csv(c)\n} \n\n#' @title Clear the results data.frame\n#' \n#' @description This function is called automatically every\n#' time Run method is called.\n#'\n#' @export\nClearResults<- function() {\n  assign(\"pkg.results\", data.frame(), pkg.globals)   \n  assign(\"pkg.parameters\", data.frame(), pkg.globals)   \n}\n\n#' Returns the model results\n#'\n#' @export\nGetResults<- function() {\n  return(get(\"pkg.results\", pkg.globals))\n}\n\n#' Stores a data.frame \n#' \n#' @param d A data frame containing one replication data\n#'\n#' @export\nSetResults<- function(d) {\n  assign(\"pkg.results\", d, pkg.globals)     \n}\n\n#' @title Concatenate results of multiple runs\n#' \n#' @description This function stores the output \n#' of the last model execution and it is intended \n#' to be used internally.\n#' \n#' @param d A data frame containing one replication data\n#'\n#' @export\nAddResults<- function(d) {\n  r<- GetResults()\n  SetResults(rbind(r,d))\n}\n\n#' @title Gets the parameters\n#' @description Returns the current set of paramters used \n#' for the last model run.\n#'\n#' @return A data.frame with parameters of the model.\n#'\n#' @export\nGetResultsParameters<- function() {\n  return(get(\"pkg.parameters\", pkg.globals))\n}\n\n#' @title Sets the parameters\n#' @description Save the current set of paramters used \n#' for the last model run.\n#' \n#' @param d -- A data.frame with parameter values\n#'\n#' @export\nSetResultsParameters<- function(d) {\n  assign(\"pkg.parameters\", d, pkg.globals)     \n}\n\n#' @title Saving simulation output\n#' \n#' @description Saves the simulation results of last call to Run(e)\n#' function.\n#' \n#' @param as The desired output type, must be csv or xls\n#' \n#' @importFrom xlsx write.xlsx\n#' @importFrom digest digest\n#' @importFrom utils write.csv\n#' @export\nSaveSimulationData<- function(as=\"csv\") {\n  # Creating output dir if needed\n  createOutputDir()\n  filename<- getId()\n  if(is.na(filename)) {\n    stop(\"Model was not initialized correctly!\")\n  }\n  \n  # The parameters of current simultation output\n  parameters<- GetResultsParameters()\n  \n  # The results of simulation run\n  results<- GetResults()\n  \n  hash <- digest(Sys.time(), algo=\"crc32\")\n  f0<- paste0(getOutputDir(),tolower(filename),\"-\",hash)\n  f1<- paste0(getOutputDir(),tolower(filename),\"-parameters-\",hash)\n  \n  switch(as,\n         csv = {\n           f0<- paste0(f0,\".csv\")\n           f1<- paste0(f1,\".csv\")\n           write.csv(results, f0, row.names=FALSE)\n           write.csv(parameters, f1, row.names=FALSE)\n         },\n         xls = { \n           f0<- paste0(f0,\".xlsx\")\n           f1<- paste0(f1,\".xlsx\")\n           write.xlsx(results, f0)\n           write.xlsx(parameters, f1)\n         })\n}\n\n##\n## ----- Below sensitivity analysis functions\n##\n\n#' @title Adds a paramter to factor collection\n#' \n#' @description Builds up the factor collection.\n#' \n#' @param factors The current factor collection\n#' @param lambda The function to apply FUN(p,min,max)\n#' @param name The name of factor\n#' @param min The minimun of parameter p\n#' @param max The maximun of parameter p\n#' \n#' @examples \\dontrun{\n#'    f<- AddFactor(name=\"Age\",min=20,max=60)\n#'    f<- AddFactor(factors=f, name=\"Weight\",min=50,max=120)}\n#' \n#' @return The collection of created factors\n#'\n#' @export\nAddFactor<- function(factors=c(), lambda=\"qunif\",name, min, max) {\n  if(max < min) {\n    stop(\"Invalid factor range!\")\n  }\n  \n  # if parameter already existe replace the current value\n  rrow<- c(lambda=lambda,name=name,min=min,max=max)\n  rownames(rrow)<- NULL\n  if(length(factors) > 0 && factors[,\"name\"] == name) {\n    i<- which(factors[,\"name\"] == name)  \n    factors[i,]<- c(rrow)\n  } else {\n    factors<- rbind(factors,c(rrow))\n  }\n  return(factors)\n}\n\n#' @title Get the number of factors\n#' \n#' @description Returns the total number of factors\n#' \n#' @param factors -- A collection of factors created with AddFactor\n#' \n#' @return The number of parameters in factors collection\n#'\n#' @export\nGetFactorsSize<- function(factors) {\n  n<- nrow(factors)\n  if(is.null(n)) n<- 0\n  return(n)\n}\n\n#' @title Corrects the LHS design matrix\n#' \n#' @description Correct the LHS sampling matrix for a \n#' specific range applying the lambda function. The default\n#' value of 'lambda' is 'qunif'.\n#' \n#' @param design -- The LHS design matrix\n#' @param factors -- THe collection of factors\n#' \n#' @return The corrected design matrix\n#'\n#' @export\nApplyFactorRange<- function(design, factors) {\n  k<- GetFactorsSize(factors)\n  d<- sapply(1:k, function(p) {match.fun(factors[p,\"lambda\"])(design[,p],as.numeric(factors[p,\"min\"]),as.numeric(factors[p,\"max\"]))})\n  \n  if(is.null(nrow(d))) {\n    ## --- Handle the case where sample size is 1\n    d<- as.data.frame(t(d))  \n  } else {\n    ## --- Handle the case where sample size > 1\n    d<- as.data.frame(d)  \n  }\n\n  names(d)<- factors[,\"name\"]\n  return(d)\n}\n\n#' @title Builds the simulation parameter set\n#' \n#' @description Merges the design matrix with parameters which \n#' will be keep fixed along simulation runs.\n#' \n#' @param design -- The experimental desing matrix for at least one factor\n#' @param parameters -- All parameters of the repast model.\n#' \n#' @return A data frame holding all parameters required for running the model\n#' \n#' @examples \\dontrun{\n#'    modeldir<- \"c:/usr/models/BactoSim(HaldaneEngine-1.0)\"\n#'    e<- Model(modeldir=modeldir,dataset=\"ds::Output\")\n#'    Load(e)\n#'    \n#'    f<- AddFactor(name=\"cyclePoint\",min=40,max=90)\n#     f<- AddFactor(factors=f, name=\"conjugationCost\",min=1,max=80)\n#'    \n#'    p<- GetSimulationParameters(e)\n#'    \n#'    d<- LatinHypercube(factors=f)\n#'    \n#'    p1<- BuildParameterSet(d,p)}\n#' \n#' @export\nBuildParameterSet<- function(design, parameters) {\n  v<- as.data.frame(design)\n  tmp.p<- parameters\n  for(n in names(v)) {\n    # Drop parameters columns which are in design matrix\n    tmp.p[n]<- NULL\n  }\n\n  # Now join two data frames\n  for(i in 1:length(names(tmp.p))) {\n    v<- cbind(tmp.p[i],v)      \n  }\n  return(v)\n}\n\n#' @title SequenceItem\n#' \n#' @description Generate a sequence from min to max using an increment\n#' based on the number of of elements in v\n#' \n#' @param v -- A column of n x k design matrix\n#' @param min -- The lower boundary of range\n#' @param max -- The uper boundary of range\n#' \n#' @return A sequence between min and max value\n#' \n#' @export\nSequenceItem<- function(v,min,max) {\n  n<- length(v)\n  delta<- (max-min)/(n-1)\n  return(seq(min,max,delta))\n}\n\n#' @title DFToMatrix\n#' \n#' @description This function converts data frames to matrix data type.\n#' \n#' @param d -- The data frame\n#' @param n -- The column names to be converted. Null for all data frame columns\n#' \n#' @return The data frame converted to a matrix\n#' @export\nDFToMatrix<- function(d,n=c()) {\n  if(length(n) == 0) {\n    n<- names(d)\n  }\n  m<- c()\n  for(k in n) {\n    m<- cbind(m,as.matrix(d[,k]))\n  }\n  colnames(m)<- n\n  return(m)\n}\n\n\n# ----- DoE - Design of Experiments  \n# ----- AoE - Analysis of Experimental Data\n\n#' @title AoE.RMSD\n#' \n#' @description  A simple Root-Mean-Square Deviation \n#' calculation.\n#' \n#' @param xs -- The simulated data set\n#' @param xe -- The experimental data set\n#' \n#' @return The RMSD value for provided datasets\n#' @export\nAoE.RMSD<- function(xs, xe) {\n  return(sqrt(mean((xs - xe)^2, na.rm = TRUE)))\n}\n\n#' @title AoE.CoV\n#' \n#' @description A simple funcion for calculate the \n#' Coefficient of Variation\n#' \n#' @param d --- The data collection\n#' @return The coefficient of variation for data\n#' \n#' @export\nAoE.CoV<- function(d) {\n  return((sd(d,na.rm = TRUE)/mean(d,na.rm = TRUE)) * 100)\n}\n\n#' @title AoE.ColumnCoV\n#' \n#' @description This function Calculates the relative squared \n#' deviation (RSD or CoV) for an used provided column name \\code{key}\n#' in the parameter \\code{dataset}. \n#' \n#' @param dataset -- A model output dataset\n#' @param key -- Column name from output dataset\n#' \n#' @return A data frame with Coefficient of variations\n#' @export\nAoE.ColumnCoV<- function(dataset, key) {\n  m.run<- dataset$run\n  if(is.null(m.run)) {\n    stop(\"The dataset is not an instance of model output!\")\n  }\n  \n  result<- c()\n  m.max<- max(m.run)\n  \n  for(i in 1:m.max) {\n    m.data<- with(dataset,dataset[run %in% seq(1,i), key])\n    result<- rbind(result,cbind(i, AoE.CoV(m.data)))\n  }\n  result<- as.data.frame(result)\n  names(result)<- c(\"sample\",\"RSD\")\n  return(result)\n}\n\n#' @title AoE.Stability\n#' \n#' @description This function verifies the stability \n#' of CoV for all columns given by parameter \\code{keys}\n#' or all dataset columns if keys is empty.\n#' \n#' @param dataset -- A model output dataset\n#' @param keys -- A list of column names\n#' \n#' @return A data frame with Coefficient of variations\n#' @export\nAoE.Stability<- function(dataset, keys=c()) {\n  if(length(keys) == 0) {\n    keys<- setdiff(names(dataset), c(\"pset\",\"random_seed\",\"run\",\"Time\"))   \n  }\n  \n  results<- c()\n  for(k in keys) {\n    v<- AoE.ColumnCoV(dataset,k)\n    v$group<- k\n    results<- rbind(results,v)\n  }\n  return(results)\n}\n  \n#' @title AoE.Base\n#' \n#' @description The Design Of Experiments Base function\n#' \n#' @param m -- The base design matrix\n#' @param factors -- A subset of model parameters\n#' @param fun -- The function which will be applied to m\n#'\n#' @return The design matrix\n#'\n#' @export\nAoE.Base<- function(m, factors=c(), fun=NULL) {\n  k<- GetFactorsSize(factors)\n  if(k == 0) {\n    stop(\"Empty factor collection!\")\n  }\n  \n  tmp.factors<- factors\n  if(!is.null(fun)) {\n    tmp.factors[,\"lambda\"]<- fun  \n  }\n  \n  # --- Apply the desired range\n  design<- ApplyFactorRange(m, tmp.factors)\n  return(design)\n}\n\n#' @title AoE.LatinHypercube \n#' \n#' @description Generate a LHS sample for model parameters\n#' \n#' @details Generate the LHS sampling for evaluating \n#' the parameters of a model.\n#' \n#' @param n -- The number of samples\n#' @param factors -- The model's parameters which will be evaluated\n#' \n#' @return The LHS design matrix for provided parameters\n#' \n#' @examples \\dontrun{\n#'  f<- AddFactor(name=\"cyclePoint\",min=40,max=90)\n#'  f<- AddFactor(factors=f, name=\"conjugationCost\",min=1,max=80)\n#'  d<- DoE.LatinHypercube(2,f)}\n#' \n#' @importFrom lhs randomLHS\n#' @export\nAoE.LatinHypercube<- function(n=10, factors=c()) {\n  k<- GetFactorsSize(factors)\n  \n  # --- Generate design matrix\n  design<- AoE.Base(randomLHS(n, k), factors)\n  return(design)\n}\n\n#' @title AoE.FullFactorial design generator\n#' \n#' @description Generate a Full Factorial sampling for evaluating \n#' the parameters of a model.\n#' \n#' @param n -- The number of samples\n#' @param factors -- The model's parameters which will be evaluated\n#' \n#' @return The Full Factorial design matrix for provided parameters\n#' \n#' @examples \\dontrun{\n#'  f<- AddFactor(name=\"cyclePoint\",min=40,max=90)\n#'  f<- AddFactor(factors=f, name=\"conjugationCost\",min=1,max=80)\n#'  d<- AoE.FullFactorial(2,f)}\n#' \n#' @export\nAoE.FullFactorial<- function(n=10, factors=c()) {\n  k<- GetFactorsSize(factors)\n  \n  # --- Generate design matrix\n  design<- AoE.Base(matrix(nrow = n, ncol = k, seq(1,n)), factors, \"SequenceItem\")\n  design<-  expand.grid(design)\n  return(design)\n}\n\n#' @title AoE.RandomSampling experiment desing generator\n#' \n#' @description Generate a Simple Random Sampling experiment design\n#' matrix.\n#' \n#' @param n -- The number of samples\n#' @param factors -- The model's parameters which will be evaluated\n#' \n#' @return The random sampling design matrix \n#' \n#' @examples \\dontrun{\n#'  f<- AddFactor(name=\"cyclePoint\",min=40,max=90)\n#'  f<- AddFactor(factors=f, name=\"conjugationCost\",min=1,max=80)\n#'  d<- AoE.RandomSampling(2,f)}\n#' \n#' @export\nAoE.RandomSampling<- function(n=10, factors=c()) {\n  k<- GetFactorsSize(factors)\n  m<- c()\n  for(i in 1:k) {\n    m<- cbind(m,runif(n))  \n  }\n  design<- AoE.Base(m, factors)\n  return(design)\n}\n\n#' @title AoE.Morris \n#' \n#' @description This is a wrapper for performing Morris's  screening\n#' method on repast models. We rely on morris method from sensitivity \n#' package.\n#' \n#' @param k -- The factors for morris screening.\n#' @param p -- The number of levels for the model's factors.\n#' @param r -- Repetitions. The number of random sampling points of Morris Method.\n#' \n#' @references Gilles Pujol, Bertrand Iooss, Alexandre Janon with contributions from Sebastien Da Veiga, Jana Fruth,\n#' Laurent Gilquin, Joseph Guillaume, Loic Le Gratiet, Paul Lemaitre, Bernardo Ramos and Taieb Touati (2015).\n#' sensitivity: Sensitivity Analysis. R package version 1.11.1.\n#' https://CRAN.R-project.org/package=sensitivity\n#' \n#' @importFrom sensitivity morris\n#' @export\nAoE.Morris<- function(k=c(),p=5,r=4) {\n  \n  k.v<- GetFactorsSize(k)\n  if(k.v == 0) {\n    stop(\"Empty factor collection!\")\n  }\n  \n  p.min<- as.numeric(k[,\"min\"])\n  p.max<- as.numeric(k[,\"max\"])\n  p.design<- list(type = \"oat\", levels = p, grid.jump = ceiling(p/2))  \n  v<- morris(NULL, k[,\"name\"], r, p.design, p.min, p.max, scale=TRUE)\n  return(v)\n}\n\n#' @title AoE.GetMorrisOutput \n#' \n#' @description  Returns a dataframe holding the Morris \n#' result set\n#' \n#' @param obj -- A reference to a morris object instance\n#' \n#' @return The results of Morris method\n#' @export\nAoE.GetMorrisOutput<- function(obj) {\n  mu <- apply(obj$ee, 2, mean)\n  mu.star <- apply(obj$ee, 2, function(x) mean(abs(x)))\n  sigma <- apply(obj$ee, 2, sd) \n  m<- t(rbind(mu,mu.star,sigma))\n  tmp<- as.data.frame(m,row.names=seq(1,nrow(m)))\n  tmp$factor<- rownames(m)\n  return(tmp)\n}\n\n#' @title AoE.Sobol\n#' \n#' @description This is a wrapper for performing Global Sensitivity\n#' Analysis using the Sobol Method provided by sensitivity \n#' package.\n#' \n#' @details This function is not intended to be used directly from \n#' user programs.\n#' \n#' @references Gilles Pujol, Bertrand Iooss, Alexandre Janon with contributions from Sebastien Da Veiga, Jana Fruth,\n#' Laurent Gilquin, Joseph Guillaume, Loic Le Gratiet, Paul Lemaitre, Bernardo Ramos and Taieb Touati (2015).\n#' sensitivity: Sensitivity Analysis. R package version 1.11.1.\n#' https://CRAN.R-project.org/package=sensitivity\n#' \n#' @param n -- The number of samples\n#' @param factors -- The model's parameters which will be evaluated\n#' @param o -- Maximum order in the ANOVA decomposition\n#' @param nb -- Number of bootstrap replicates\n#' @param fun.doe -- The sampling function to be used for sobol method\n#' @param fun.sobol -- The sobol implementation\n#' \n#' \n#' @importFrom sensitivity sobol\n#' @export\nAoE.Sobol<- function(n=100, factors=c(), o=2, nb=100, fun.doe=AoE.LatinHypercube, fun.sobol=sobol) {\n  p.x1<- fun.doe(n,factors)\n  p.x2<- fun.doe(n,factors)\n  v<- fun.sobol(model = NULL, X1 = p.x1,X2 = p.x2, order = o, nboot = nb) \n  return(v)\n}\n  \n##\n## ----- Below Plot functions\n##\n\n#' @title Plot stability of output\n#' \n#' @description Generate plot for visually access the stability of \n#' coefficient of variation as function of simulation sample size.\n#' \n#' @param obj -- An instance of Morris Object \\code{\\link{AoE.Morris}}\n#' @param type -- The chart type (mu*sigma|musigma|mu*mu)\n#' @param title -- Chart title, may be null\n#' \n#' @return The resulting ggplot2 plot object\n#' \n#' @importFrom ggplot2 ggplot aes geom_point\n#' @export\nPlot.Stability<- function(obj, title= NULL) {\n  \n  if(is.null(obj$RSD)) {\n    stop(\"Invalid object instance!\")\n  }\n  \n  d<- obj\n  \n  p<- ggplot(d, aes(sample, RSD)) \n  \n  p<- p + labs(y = expression(\"RSD\"))\n  p<- p + labs(x = expression(\"sample size\"))\n  \n  if(!is.null(title)) {\n    p<- p + ggtitle(title)\n  }\n  \n  p<- p + aes(shape = factor(group)) \n  p<- p + geom_line(aes(colour = factor(group)), size = 1)\n  \n  return(p)\n}\n\n#' @title Plot of Morris output\n#' \n#' @description Generate plot for Morris's screening method\n#' \n#' @param obj -- An instance of Morris Object \\code{\\link{AoE.Morris}}\n#' @param type -- The chart type (mu*sigma|musigma|mu*mu)\n#' @param title -- Chart title, may be null\n#' \n#' @return The resulting ggplot2 plot object\n#' \n#' @importFrom ggplot2 ggplot aes geom_point\n#' @export\nPlot.Morris<- function(obj, type, title= NULL) {\n  # --- Check if we received a valir morris object\n  if(is.null(obj$call)) {\n    stop(\"Invalid Morris object instance!\")\n  }\n  \n  d<- AoE.GetMorrisOutput(obj)\n  \n  switch(type,\n    \"mu*sigma\" = { \n      p<- ggplot(d, aes(mu.star, sigma))  \n      p<- p + labs(y = expression(sigma))\n      p<- p + labs(x = expression(paste(mu,\"*\")))\n    },\n    \n    \"musigma\" = { \n      p<- ggplot(d, aes(mu, sigma))  \n      p<- p + labs(y = expression(sigma))\n      p<- p + labs(x = expression(mu))\n    },\n    \n    \"mu*mu\" = {\n      p<- ggplot(d, aes(mu.star, mu))\n      p<- p + labs(y = expression(mu))\n      p<- p + labs(x = expression(paste(mu,\"*\")))\n    },\n    \n    stop(\"Invalid chart type!\")\n  )\n  \n  if(!is.null(title)) {\n    p<- p + ggtitle(title)\n  }\n  \n  p<- p + aes(shape = factor(factor)) \n  p<- p + geom_point(aes(colour = factor(factor)), size = 4)\n  p<- p + geom_point(colour=\"grey90\", size = 1.5)\n  \n  return(p)\n}\n\n##\n## ----- Below Easy Api Methods\n##\n\n#' @title Easy.getChart\n#' \n#' @description Returns the chart instance\n#' \n#' @param obj --- A reference to the output of Easy.Stability\n#' @param key --- The param name\n#' \n#' @return The plot instance\n#' @export\nEasy.getChart<- function(obj, key) {\n  if(is.null(obj$charts)) {\n    stop(\"Not an instance of Easy API result!\")\n  }\n  charts<- obj$charts\n  chart<- charts[charts[,1] ==  key,]\n  return(chart)\n}\n\n#' @title Easy API for output stability\n#' \n#' @description This functions run model several times in order to determine \n#' how many experiment replications are required for model's output being stable\n#' (i.e. the convergence of standard deviation)\n#' \n#' @param m.dir The installation directory of some repast model\n#' @param m.ds The name of any model aggregate dataset\n#' @param m.time The total simulated time\n#' @param parameters -- The factors or model's parameter list\n#' @param sampling -- The number of factor samples.\n#' @param tries -- The number of experiment replications\n#' @param vars -- The model's output variables for compute CoV\n#' @param FUN -- THe calibration function.\n#' \n#' @export\nEasy.Stability<- function(m.dir, m.ds, m.time=300, parameters, sampling=1, tries=100, vars= c(), FUN) {\n  my.model<- Model(modeldir=m.dir,maxtime = m.time, dataset=m.ds)\n  Load(my.model)\n\n  ## --- Sample the parameter space\n  sampling<- AoE.RandomSampling(sampling, parameters)\n  \n  ## --- Get the model declared paramters\n  parms<- GetSimulationParameters(my.model)\n  \n  ## --- Build the experimental parameter set\n  exp.design<- BuildParameterSet(sampling,parms)\n  \n  ## --- Run the experimental setup\n  exp<- RunExperiment(my.model,r=tries,exp.design,FUN)\n  \n  ## --- Get the raw data set for evaluate the Coefficient of Variation\n  d<- getExperimentDataset(exp)\n  \n  ## --- Calculate the coefficient of variation\n  rsd<- AoE.Stability(d, vars)\n  \n  charts<- c()\n  for(group in unique(rsd$group)) {\n    chart<- Plot.Stability(rsd[rsd$group == group, ],\"Simulation output stability\")  \n    charts<- rbind(charts, list(group=group,plot=chart))\n  }\n  \n  if(length(vars) != 0) {\n    chart<- Plot.Stability(rsd,\"Simulation output stability\")\n    charts<- rbind(charts, list(group=\"all\",plot=chart))\n  }\n  \n  results<- list(experiment=exp, charts=charts)\n  return(results)\n  \n}\n\n#' @title Easy API for Morris's screening method\n#' \n#' @description This functions wraps all calls to perform Morris method.\n#' \n#' @param m.dir The installation directory of some repast model\n#' @param m.ds The name of any model aggregate dataset\n#' @param m.time The total simulated time\n#' @param parameters -- The factors for morris screening.\n#' @param mo.p -- The number of levels for the model's factors.\n#' @param mo.r -- Repetitions. The number of random sampling points of Morris Method.\n#' @param exp.r -- The number of experiment replications\n#' @param FUN -- THe calibration function.\n#' \n#' @export\nEasy.Morris<- function(m.dir, m.ds, m.time=300, parameters, mo.p, mo.r, exp.r, FUN) {\n  my.model<- Model(modeldir=m.dir,maxtime = m.time, dataset=m.ds)\n  Load(my.model)\n  \n  ## --- Create Morris object\n  v.morris<- AoE.Morris(f,p=mo.p,r=mo.r)\n  \n  ## --- Get the model declared paramters\n  parms<- GetSimulationParameters(my.model)\n  \n  ## --- Build the experimental parameter set\n  exp.design<- BuildParameterSet(v.morris$X,parms)\n  \n  ## --- Run the experimental setup\n  exp<- RunExperiment(my.model,r=exp.r,exp.design,FUN)\n  \n  charts<- c()\n  o<- getExperimentOutput(exp)\n  for(k in colnames(o)) {\n    if(k != \"pset\") {\n      m<- t(DFToMatrix(getExperimentOutput(exp),c(k)))\n      tell(v.morris,m)\n      \n      ## --- Plot Morris output\n      mustar<- Plot.Morris(v.morris,\"mu*sigma\", paste(\"criteria\",k))\n      musigma<- Plot.Morris(v.morris,\"musigma\", paste(\"criteria\",k))\n      mumu<- Plot.Morris(v.morris,\"mu*mu\", paste(\"criteria\",k))\n      charts<- rbind(charts,list(mu.star=mustar,mu=musigma,mumu=mumu))\n    } \n    results<- list(experiment=exp, charts=charts)\n  }\n  return(results)\n}\n\n#' @title Easy API for Sobol's SA method\n#' \n#' @description This functions wraps all required calls to perform \n#' Sobol method for global sensitivity analysis.\n#' \n#' @param m.dir The installation directory of some repast model\n#' @param m.ds The name of any model aggregate dataset\n#' @param m.time The total simulated time\n#' @param parameters -- The factors for morris screening.\n#' @param exp.r -- The number of experiment replications\n#' @param FUN -- THe calibration function.\n#' \n#' @export\nEasy.Sobol<- function(m.dir, m.ds, m.time=300, parameters, exp.r=1, FUN) {\n  ## --- Instantiate the model\n  my.model<- Model(modeldir=m.dir,maxtime = m.time, dataset=m.ds)\n  Load(my.model)\n  \n  ## --- Get the model declared paramters\n  parms<- GetSimulationParameters(my.model)\n  \n  ## --- Create a Sobol object\n  my.obj<- AoE.Sobol(n=10,f)\n  \n  # Build the experimental parameter set\n  exp.design<- BuildParameterSet(my.obj$X,parms)\n  \n  ## --- Run the experimental setup\n  exp<- RunExperiment(my.model,r=exp.r,exp.design,FUN)\n  \n  charts<- c()\n  o<- getExperimentOutput(exp)\n  for(k in colnames(o)) {\n    if(k != \"pset\") {\n      m<- t(DFToMatrix(getExperimentOutput(exp),c(k)))\n      tell(my.obj,m)\n      p<- plot(my.obj)\n      charts<- rbind(charts,list(chart=p))\n    } \n    results<- list(experiment=exp, charts=charts)\n  }\n  \n  return(results)\n}\n  \n",
    "created" : 1446662519588.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1789353327",
    "id" : "A220BA1C",
    "lastKnownWriteTime" : 1459276668,
    "path" : "~/R-Projects/RRepast/R/RRepast.R",
    "project_path" : "R/RRepast.R",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "type" : "r_source"
}